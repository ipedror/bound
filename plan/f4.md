# üìÑ FASE 4: UI Navigation & Routing

## ESTRUTURA GERAL

A **Fase 4** implementa navega√ß√£o SPA (Single Page Application) completa, roteamento entre telas, e UI de navega√ß√£o. Seu objetivo √© criar:

1. **React Router Setup** com rotas para Home, Area, Content, Graph
2. **Telas Principais** (HomePage, AreaPage, ContentPage, GraphPage) que consomem dados via hooks
3. **Navbar Global** com bot√µes de navega√ß√£o, exportar, importar, settings
4. **Sidebar/Modals** para criar √°reas, conte√∫dos, propriedades
5. **Keyboard Shortcuts** (Ctrl+S export, Ctrl+E emoji picker, etc.)
6. **Responsive Design** modo escuro aplicado a toda UI

Ao final da Fase 4, voc√™ ter√° uma **aplica√ß√£o SPA completa e funcional**, onde o usu√°rio navega entre visualiza√ß√µes, cria/edita conte√∫dos, v√™ o grafo, e pode exportar/importar estado.

***

## FASE 4: UI Navigation & Routing

### ETAPA 1: Configurar React Router & Estrutura de Rotas

**Objetivo:**  
Instalar React Router e configurar estrutura de rotas principais.

**Arquivos principais a tocar:**
- `package.json`
- `src/routes/index.tsx` (defini√ß√£o de rotas)
- `src/App.tsx` (refactored para usar router)
- `src/layouts/MainLayout.tsx` (layout wrapper com navbar)

**Prompt para IA:**

```text
Voc√™ √© um engenheiro frontend especializado em SPA routing com React Router.

TAREFA:
Instalar React Router e configurar estrutura de rotas para a aplica√ß√£o BOUND.

CONTEXTO IMPORTANTE:
- Rotas principais: /, /area/:areaId, /content/:contentId, /graph
- Layout wrapper com Navbar global (logo, home button, export, import, settings).
- Modo escuro: dark backgrounds, sem brancos (exceto em formas/caracteres).
- Sem UI complexa por enquanto; apenas estrutura de rotas.

FUNCIONALIDADE DESEJADA:

1. **Instala√ß√£o React Router:**
   - `npm install react-router-dom`

2. **Rotas Principais:**
   ```typescript
   // src/routes/index.tsx
   import { createBrowserRouter } from 'react-router-dom';
   import HomePage from '../pages/HomePage';
   import AreaPage from '../pages/AreaPage';
   import ContentPage from '../pages/ContentPage';
   import GraphPage from '../pages/GraphPage';
   import MainLayout from '../layouts/MainLayout';

   export const router = createBrowserRouter([
     {
       path: '/',
       element: <MainLayout />,
       children: [
         { index: true, element: <HomePage /> },
         { path: 'area/:areaId', element: <AreaPage /> },
         { path: 'content/:contentId', element: <ContentPage /> },
         { path: 'graph', element: <GraphPage /> },
         { path: '*', element: <NotFoundPage /> },
       ],
     },
   ]);
   ```

3. **MainLayout Component:**
   - Renderiza Navbar no topo
   - Outlet para conte√∫do din√¢mico
   - Sidebar (expand√≠vel) com lista de √°reas (opcional para Fase 4)
   - Dark background

4. **App.tsx Refactored:**
   ```typescript
   import { RouterProvider } from 'react-router-dom';
   import { router } from './routes';

   export default function App() {
     return <RouterProvider router={router} />;
   }
   ```

INSTRU√á√ïES T√âCNICAS:

1. Execute:
   ```bash
   npm install react-router-dom
   ```

2. Crie `src/routes/index.tsx` com config de rotas.

3. Crie `src/layouts/MainLayout.tsx`:
   - Renderiza Navbar
   - Renderiza Outlet (conte√∫do din√¢mico)
   - Fundo escuro

4. Crie `src/pages/`:
   - `HomePage.tsx` (placeholder)
   - `AreaPage.tsx` (placeholder)
   - `ContentPage.tsx` (placeholder)
   - `GraphPage.tsx` (placeholder)
   - `NotFoundPage.tsx` (404)

5. Sem testes complexos; apenas type check.

SA√çDA ESPERADA:
- React Router instalado.
- Rotas configuradas em `src/routes/index.tsx`.
- `src/layouts/MainLayout.tsx` com Navbar.
- `src/pages/` com placeholders.
- `src/App.tsx` refatorado.

CRIT√âRIOS DE ACEITE:
- [ ] `npm run type-check` passa.
- [ ] `npm run dev` inicia sem erros.
- [ ] Navegar entre rotas funciona (React Router working).
- [ ] Navbar renderiza em todas as p√°ginas.

N√ÉO FAZER:
- N√£o implementar conte√∫do das p√°ginas (pr√≥ximas etapas).
```

***

### ETAPA 2: Implementar Navbar & Componentes Globais

**Objetivo:**  
Criar navbar global com bot√µes de navega√ß√£o, exportar, importar, settings.

**Arquivos principais a tocar:**
- `src/components/Navbar.tsx`
- `src/components/ExportButton.tsx`
- `src/components/ImportButton.tsx`
- `src/components/SettingsMenu.tsx`

**Prompt para IA:**

```text
Voc√™ √© um expert em UI design e React components.

TAREFA:
Implementar Navbar global: componente que renderiza no topo de todas as telas, com bot√µes de navega√ß√£o, export, import, settings.

CONTEXTO IMPORTANTE:
- Navbar √© global (renderizado em MainLayout).
- Modo escuro: background escuro (ex: #0f172a), texto claro.
- Bot√µes: Home, Graph, Export, Import, Settings.
- Export: download .bound file (integrado com BoundSerializer).
- Import: upload .bound file (integrado com BoundSerializer, merge/replace option).
- Settings: modal com prefer√™ncias (theme, language, etc.).

FUNCIONALIDADE DESEJADA:

1. **Navbar Component:**
   - Logo/branding "BOUND" (texto ou √≠cone)
   - Button: Home (navigate to /)
   - Button: Graph (navigate to /graph)
   - Button: Export (download .bound)
   - Button: Import (upload .bound, merge/replace)
   - Button: Settings (open modal)
   - Right side: user avatar (placeholder) ou settings icon

2. **ExportButton Component:**
   - Click ‚Üí trigger download de .bound file
   - Filename: `bound-${timestamp}.bound`
   - Loader durante export
   - Toast de sucesso/erro

3. **ImportButton Component:**
   - Click ‚Üí file input (hidden)
   - Selecionar .bound file
   - Valida arquivo
   - Modal merge/replace option
   - Loader durante import
   - Toast de sucesso/erro

4. **SettingsMenu Component:**
   - Modal com op√ß√µes:
     - Theme: Dark (default, fixed para Phase 4)
     - Auto-save: on/off
     - Graph layout: force-directed, circular, etc.
     - About: vers√£o, documenta√ß√£o
   - Close button

INSTRU√á√ïES T√âCNICAS:

1. Crie `src/components/Navbar.tsx`:
   - Flexbox layout (header)
   - Dark background: #0f172a
   - Logo left, buttons right
   - Use React Router `useNavigate()` para navegar

2. Crie `src/components/ExportButton.tsx`:
   ```typescript
   export function ExportButton() {
     const { state } = useAppStore(useShallow((s) => ({ state: s.state })));
     const [isLoading, setIsLoading] = useState(false);

     const handleExport = async () => {
       setIsLoading(true);
       try {
         const file = await BoundSerializer.encode(state);
         const blob = new Blob([file], { type: 'application/octet-stream' });
         const url = URL.createObjectURL(blob);
         const a = document.createElement('a');
         a.href = url;
         a.download = `bound-${Date.now()}.bound`;
         a.click();
         URL.revokeObjectURL(url);
         // Toast: "Exported successfully"
       } catch (err) {
         // Toast: "Export failed: " + err
       } finally {
         setIsLoading(false);
       }
     };

     return <button onClick={handleExport} disabled={isLoading}>Export</button>;
   }
   ```

3. Crie `src/components/ImportButton.tsx`:
   ```typescript
   export function ImportButton() {
     const { loadFromStorage } = useStorage();
     const fileInputRef = useRef<HTMLInputElement>(null);
     const [isLoading, setIsLoading] = useState(false);

     const handleFileSelect = async (e: React.ChangeEvent<HTMLInputElement>) => {
       const file = e.target.files?.;
       if (!file) return;

       setIsLoading(true);
       try {
         const content = await file.text();
         const importedState = await BoundSerializer.decode(content);
         
         // Modal: merge or replace?
         // For now, ask user
         const policy = window.confirm('Replace current state? (Cancel = Merge)') ? 'replace' : 'merge';
         
         // Apply import
         if (policy === 'replace') {
           useAppStore.getState().setState(importedState);
         } else {
           // Merge logic (future feature)
         }
         
         // Toast: "Imported successfully"
       } catch (err) {
         // Toast: "Import failed: " + err
       } finally {
         setIsLoading(false);
       }
     };

     return (
       <>
         <button onClick={() => fileInputRef.current?.click()} disabled={isLoading}>
           Import
         </button>
         <input
           ref={fileInputRef}
           type="file"
           accept=".bound"
           onChange={handleFileSelect}
           style={{ display: 'none' }}
         />
       </>
     );
   }
   ```

4. Crie `src/components/SettingsMenu.tsx`:
   - Modal simple com form de op√ß√µes

5. Estilos com Tailwind (ou inline styles):
   - Dark background
   - Clear buttons
   - Hover effects

SA√çDA ESPERADA:
- `src/components/Navbar.tsx`
- `src/components/ExportButton.tsx`
- `src/components/ImportButton.tsx`
- `src/components/SettingsMenu.tsx`

CRIT√âRIOS DE ACEITE:
- [ ] Navbar renderiza sem erros.
- [ ] Bot√µes navegam corretamente (React Router).
- [ ] Export baixa arquivo .bound.
- [ ] Import faz upload e aplica estado.
- [ ] Settings modal funciona.
- [ ] Modo escuro aplicado (backgrounds escuros, textos claros).

N√ÉO FAZER:
- N√£o implementar merge logic ainda (Future feature).
- N√£o fazer autentica√ß√£o (offline app).
```

***

### ETAPA 3: Implementar HomePage

**Objetivo:**  
Criar tela inicial com lista de √°reas, bot√£o criar nova √°rea, e navega√ß√£o para areas.

**Arquivos principais a tocar:**
- `src/pages/HomePage.tsx`
- `src/components/AreaList.tsx`
- `src/components/CreateAreaModal.tsx`

**Prompt para IA:**

```text
Voc√™ √© um expert em UI/UX e React components.

TAREFA:
Implementar HomePage: tela inicial que mostra lista de √°reas (com conte√∫do count), bot√£o criar nova √°rea, e links para navegar para cada √°rea.

CONTEXTO IMPORTANTE:
- HomePage √© o ponto de entrada da app.
- Exibe todas as √°reas com card layout.
- Cada card mostra: nome da √°rea, quantidade de conte√∫dos, thumbnail do mini-grafo.
- Bot√£o "+" para criar nova √°rea.
- Click em card ‚Üí navega para /area/:areaId.
- Modo escuro: dark backgrounds, clear cards.

FUNCIONALIDADE DESEJADA:

1. **HomePage Component:**
   - T√≠tulo "Your Areas" ou similar
   - Grid de cards (2-3 columns, responsivo)
   - Cada card: area name, content count, action buttons (edit, delete)
   - Button "New Area" (modal ou inline form)
   - Click card ‚Üí navigate to area

2. **AreaList Component:**
   - Map areas from hook
   - Render card for each area
   - Handle click, edit, delete

3. **CreateAreaModal Component:**
   - Form: area name input
   - Buttons: Create, Cancel
   - Validation: name n√£o vazio, √∫nica
   - On success: refresh list

INSTRU√á√ïES T√âCNICAS:

1. Crie `src/pages/HomePage.tsx`:
   ```typescript
   export default function HomePage() {
     const { areas, create } = useAreas();
     const [showCreateModal, setShowCreateModal] = useState(false);

     return (
       <div className="page home-page">
         <h1>Your Areas</h1>
         <button onClick={() => setShowCreateModal(true)}>+ New Area</button>
         
         <AreaList areas={areas} />
         
         {showCreateModal && (
           <CreateAreaModal
             onCreate={(name) => {
               create(name);
               setShowCreateModal(false);
             }}
             onCancel={() => setShowCreateModal(false)}
           />
         )}
       </div>
     );
   }
   ```

2. Crie `src/components/AreaList.tsx`.

3. Crie `src/components/CreateAreaModal.tsx`.

4. Estilos:
   - Dark backgrounds (#0f172a for main, #1e293b for cards)
   - Grid layout (CSS Grid ou Flexbox)
   - Hover effects
   - Responsive (mobile: 1 column, tablet: 2, desktop: 3)

SA√çDA ESPERADA:
- `src/pages/HomePage.tsx`
- `src/components/AreaList.tsx`
- `src/components/CreateAreaModal.tsx`

CRIT√âRIOS DE ACEITE:
- [ ] HomePage renderiza sem erros.
- [ ] √Åreas exibidas em cards.
- [ ] Criar nova √°rea funciona.
- [ ] Click em card navega para /area/:areaId.
- [ ] Modo escuro aplicado.
- [ ] Responsivo (mobile, tablet, desktop).

N√ÉO FAZER:
- N√£o fazer mini-grafo no card (complexo; Fase 5+).
```

***

### ETAPA 4: Implementar AreaPage

**Objetivo:**  
Criar tela de √°rea que mostra lista de conte√∫dos, mini-grafo, bot√£o criar novo conte√∫do.

**Arquivos principais a tocar:**
- `src/pages/AreaPage.tsx`
- `src/components/ContentList.tsx`
- `src/components/MiniGraph.tsx` (opcional, pode ser simples)
- `src/components/CreateContentModal.tsx`

**Prompt para IA:**

```text
Voc√™ √© um expert em UI/UX e React components.

TAREFA:
Implementar AreaPage: tela que mostra lista de conte√∫dos de uma √°rea, mini-grafo dos n√≥s dessa √°rea, bot√£o criar novo conte√∫do.

CONTEXTO IMPORTANTE:
- AreaPage √© renderizada em /area/:areaId.
- Exibe nome da √°rea (com breadcrumb ou header).
- Grid de conte√∫dos (abertos e fechados).
- Cada conte√∫do: t√≠tulo, emoji, status badge (open/closed), action buttons (edit, delete).
- Mini-grafo mostrando n√≥s dessa √°rea (simples, ou pode ser omitido por enquanto).
- Bot√£o "New Content".
- Click em conte√∫do ‚Üí navigate to /content/:contentId.
- Modo escuro.

FUNCIONALIDADE DESEJADA:

1. **AreaPage Component:**
   - Header: area name, breadcrumb (Home > Area)
   - Button "New Content"
   - ContentList (grid)
   - MiniGraph (optional, simples)
   - Loading states

2. **ContentList Component:**
   - Map contents from hook
   - Render card for each content
   - Show status badge (open/closed)
   - Show emoji
   - Action buttons (edit, delete)
   - Click ‚Üí navigate to /content/:contentId

3. **MiniGraph Component (simples):**
   - Para esta fase, pode ser um placeholder
   - Ou Canvas simples mostrando n√≥s como c√≠rculos
   - Ou usar Cytoscape com container pequeno
   - Clic√°vel: click em n√≥ ‚Üí navigate a /content/:contentId

4. **CreateContentModal Component:**
   - Form: content title input
   - Buttons: Create, Cancel
   - On success: refresh list

INSTRU√á√ïES T√âCNICAS:

1. Crie `src/pages/AreaPage.tsx`:
   ```typescript
   export default function AreaPage() {
     const { areaId } = useParams();
     const { area, contents, createContent } = useArea(areaId);
     const [showCreateModal, setShowCreateModal] = useState(false);

     if (!area) return <div>Area not found</div>;

     return (
       <div className="page area-page">
         <h1>{area.name}</h1>
         <button onClick={() => setShowCreateModal(true)}>+ New Content</button>
         
         <ContentList contents={contents} />
         <MiniGraph areaId={areaId} />
         
         {showCreateModal && (
           <CreateContentModal
             onCreate={(title) => {
               createContent(title);
               setShowCreateModal(false);
             }}
             onCancel={() => setShowCreateModal(false)}
           />
         )}
       </div>
     );
   }
   ```

2. Crie `src/components/ContentList.tsx`.

3. Crie `src/components/CreateContentModal.tsx`.

4. Crie `src/components/MiniGraph.tsx` (simples por enquanto).

SA√çDA ESPERADA:
- `src/pages/AreaPage.tsx`
- `src/components/ContentList.tsx`
- `src/components/CreateContentModal.tsx`
- `src/components/MiniGraph.tsx`

CRIT√âRIOS DE ACEITE:
- [ ] AreaPage renderiza sem erros.
- [ ] Conte√∫dos exibidos em lista/grid.
- [ ] Criar novo conte√∫do funciona.
- [ ] Click em conte√∫do navega para /content/:contentId.
- [ ] Status badge (open/closed) exibido.
- [ ] Modo escuro aplicado.

N√ÉO FAZER:
- N√£o fazer minigrafo complexo (pode ser simples ou placeholder).
```

***

### ETAPA 5: Implementar ContentPage

**Objetivo:**  
Criar tela de edi√ß√£o de conte√∫do que integra CanvasEditor + PropertyEditor sidebar.

**Arquivos principais a tocar:**
- `src/pages/ContentPage.tsx`
- `src/components/PropertyEditor.tsx`
- `src/components/PropertyList.tsx`
- `src/components/CreatePropertyModal.tsx`
- `src/components/EmojiPicker.tsx`

**Prompt para IA:**

```text
Voc√™ √© um expert em UI/UX e React components.

TAREFA:
Implementar ContentPage: tela que mostra CanvasEditor + sidebar com PropertyEditor, emoji picker, bot√µes fechar/salvar.

CONTEXTO IMPORTANTE:
- ContentPage renderizada em /content/:contentId.
- Main area: CanvasEditor (quadro negro).
- Sidebar: properties list, emoji picker, fechar button.
- Header: content title, breadcrumb.
- Modo escuro.
- Integra√ß√£o com useContent hook para persist√™ncia.

FUNCIONALIDADE DESEJADA:

1. **ContentPage Component:**
   - Header: content title, breadcrumb (Home > Area > Content)
   - Main: CanvasEditor (from Fase 2)
   - Sidebar: properties, emoji, actions
   - Button "Close Content" (muda status = 'closed')
   - Button "Delete" (com confirma√ß√£o)

2. **PropertyEditor Component:**
   - List de propriedades
   - Add button (abre modal)
   - Each property: name, type, value, edit, delete buttons
   - Click edit ‚Üí abre modal de edi√ß√£o

3. **PropertyList Component:**
   - Map properties
   - Render each with type badge
   - Action buttons

4. **CreatePropertyModal Component:**
   - Form: name, type (select), value (input type-specific)
   - Buttons: Create, Cancel
   - Validation: name n√£o vazio, type v√°lido

5. **EmojiPicker Component:**
   - Simples: grid de emojis populares
   - Ou: input com emoji selector
   - On select: atualiza content.emoji via hook

INSTRU√á√ïES T√âCNICAS:

1. Crie `src/pages/ContentPage.tsx`:
   ```typescript
   export default function ContentPage() {
     const { contentId } = useParams();
     const { content, open, close, updateTitle, deleteContent } = useContent(contentId);
     const { goToArea } = useNavigation();

     if (!content) return <div>Content not found</div>;

     const handleClose = () => {
       close();
       goToArea(content.areaId);
     };

     const handleDelete = () => {
       if (confirm('Delete this content?')) {
         deleteContent();
         goToArea(content.areaId);
       }
     };

     return (
       <div className="page content-page">
         <header>
           <h1>{content.title}</h1>
           <input
             type="text"
             value={content.title}
             onChange={(e) => updateTitle(e.target.value)}
             placeholder="Content title"
           />
         </header>

         <div className="content-layout">
           <main className="canvas-area">
             <CanvasEditor contentId={contentId} />
           </main>

           <aside className="property-sidebar">
             <EmojiPicker contentId={contentId} />
             <PropertyEditor contentId={contentId} />
             <div className="actions">
               <button onClick={handleClose}>Close Content</button>
               <button onClick={handleDelete} className="delete">Delete</button>
             </div>
           </aside>
         </div>
       </div>
     );
   }
   ```

2. Crie `src/components/PropertyEditor.tsx`.

3. Crie `src/components/PropertyList.tsx`.

4. Crie `src/components/CreatePropertyModal.tsx`.

5. Crie `src/components/EmojiPicker.tsx`.

6. Layout com CSS Grid ou Flexbox:
   - Main: 70-80% width (canvas)
   - Sidebar: 20-30% width (properties)
   - Responsivo: mobile empilhado

SA√çDA ESPERADA:
- `src/pages/ContentPage.tsx`
- `src/components/PropertyEditor.tsx`
- `src/components/PropertyList.tsx`
- `src/components/CreatePropertyModal.tsx`
- `src/components/EmojiPicker.tsx`

CRIT√âRIOS DE ACEITE:
- [ ] ContentPage renderiza sem erros.
- [ ] CanvasEditor integrado e funcional.
- [ ] Propriedades exibidas e edit√°veis.
- [ ] Emoji picker funciona.
- [ ] Fechar conte√∫do funciona (status = 'closed').
- [ ] Deletar conte√∫do funciona.
- [ ] Modo escuro aplicado.
- [ ] Layout responsivo.

N√ÉO FAZER:
- N√£o refazer CanvasEditor; apenas integrar do Fase 2.
```

***

### ETAPA 6: Implementar GraphPage

**Objetivo:**  
Criar tela de grafo global que mostra todos os n√≥s/arestas de todas as √°reas.

**Arquivos principais a tocar:**
- `src/pages/GraphPage.tsx`

**Prompt para IA:**

```text
Voc√™ √© um expert em UI/UX e React.

TAREFA:
Implementar GraphPage: tela que mostra GraphView (do Fase 3) com todos os n√≥s de todas as √°reas.

CONTEXTO IMPORTANTE:
- GraphPage renderizada em /graph.
- Main: GraphView (full-screen ou quase).
- Header: t√≠tulo "Global Graph"
- GraphView integrado (do Fase 3).
- Modo escuro.

FUNCIONALIDADE DESEJADA:

1. **GraphPage Component:**
   - Header: "Global Graph"
   - GraphView (areaId = undefined, mostra todas as √°reas)
   - Click em n√≥ ‚Üí navigate to /content/:contentId
   - Keyboard: Escape para voltar

INSTRU√á√ïES T√âCNICAS:

1. Crie `src/pages/GraphPage.tsx`:
   ```typescript
   export default function GraphPage() {
     const { goToContent, goToArea } = useNavigation();

     return (
       <div className="page graph-page">
         <header>
           <h1>Global Graph</h1>
         </header>

         <GraphView areaId={undefined} onNodeClick={goToContent} />
       </div>
     );
   }
   ```

2. Integrar GraphView do Fase 3.

3. Modo escuro.

SA√çDA ESPERADA:
- `src/pages/GraphPage.tsx`

CRIT√âRIOS DE ACEITE:
- [ ] GraphPage renderiza sem erros.
- [ ] GraphView mostra todos os n√≥s de todas as √°reas.
- [ ] Click em n√≥ navega para /content/:contentId.
- [ ] Modo escuro aplicado.

N√ÉO FAZER:
- N√£o refazer GraphView; apenas integrar do Fase 3.
```

***

### ETAPA 7: Implementar Keyboard Shortcuts & Integra√ß√£o Final

**Objetivo:**  
Adicionar atalhos de teclado globais, integra√ß√£o de hooks, e valida√ß√£o final.

**Arquivos principais a tocar:**
- `src/hooks/useKeyboardShortcuts.ts`
- `src/App.tsx` (integra√ß√£o de shortcuts)
- `tests/integration/ui.integration.test.ts`

**Prompt para IA:**

```text
Voc√™ √© um expert em UX e React hooks.

TAREFA:
Implementar keyboard shortcuts globais e integra√ß√£o final de UI + hooks.

CONTEXTO IMPORTANTE:
- Atalhos globais: Ctrl+S (export), Ctrl+E (emoji picker), Escape (voltar), etc.
- Integra√ß√£o de todos os hooks nos componentes.
- Sem perda de funcionalidade ao navegar.

FUNCIONALIDADE DESEJADA:

1. **useKeyboardShortcuts Hook:**
   ```typescript
   export function useKeyboardShortcuts() {
     const navigate = useNavigate();
     const { goHome, goToArea, goToContent } = useNavigation();

     useEffect(() => {
       const handleKeyDown = (e: KeyboardEvent) => {
         // Ctrl+S: export
         if ((e.ctrlKey || e.metaKey) && e.key === 's') {
           e.preventDefault();
           document.querySelector('[data-test="export-button"]')?.click();
         }
         // Ctrl+E: emoji picker (context-dependent)
         if ((e.ctrlKey || e.metaKey) && e.key === 'e') {
           e.preventDefault();
           document.querySelector('[data-test="emoji-picker"]')?.focus();
         }
         // Escape: voltar
         if (e.key === 'Escape') {
           navigate(-1);
         }
       };

       window.addEventListener('keydown', handleKeyDown);
       return () => window.removeEventListener('keydown', handleKeyDown);
     }, [navigate]);
   }
   ```

2. **Integra√ß√£o em App.tsx:**
   - Adicionar useKeyboardShortcuts no componente raiz

3. **Integration Tests:**
   - Full workflow: home ‚Üí create area ‚Üí create content ‚Üí edit canvas ‚Üí close ‚Üí grafo ‚Üí export/import
   - Navigation: todas as rotas funcionam
   - Keyboard shortcuts: Ctrl+S, Ctrl+E, Escape

INSTRU√á√ïES T√âCNICAS:

1. Crie `src/hooks/useKeyboardShortcuts.ts`.

2. Adicione em `src/App.tsx`:
   ```typescript
   export default function App() {
     useKeyboardShortcuts();
     return <RouterProvider router={router} />;
   }
   ```

3. Testes de integra√ß√£o E2E (Vitest + React Testing Library).

SA√çDA ESPERADA:
- `src/hooks/useKeyboardShortcuts.ts`
- `src/App.tsx` (integrado)
- `tests/integration/ui.integration.test.ts`

CRIT√âRIOS DE ACEITE:
- [ ] Keyboard shortcuts funcionam.
- [ ] Todas as rotas naveg√°veis.
- [ ] Nenhuma perda de funcionalidade.
- [ ] Modo escuro aplicado globalmente.

N√ÉO FAZER:
- N√£o fazer E2E com Playwright (Fase 6).
```

***

### ETAPA 8: Estilos & Design Final (Tailwind + Dark Mode)

**Objetivo:**  
Aplicar estilos consistentes com Tailwind CSS e dark mode theme em toda a aplica√ß√£o.

**Arquivos principais a tocar:**
- `tailwind.config.ts`
- `src/styles/globals.css`
- `src/components/*.tsx` (adicionar classes Tailwind)

**Prompt para IA:**

```text
Voc√™ √© um expert em Tailwind CSS e design systems.

TAREFA:
Aplicar estilos consistentes com Tailwind CSS, garantindo modo escuro em toda a aplica√ß√£o, sem backgrounds brancos.

CONTEXTO IMPORTANTE:
- Modo escuro OBRIGAT√ìRIO: backgrounds escuros (#0f172a, #1e293b), textos claros.
- Sem backgrounds brancos (exceto em formas/caracteres do canvas).
- Tema consistente: cores, espa√ßamentos, tipografia.
- Responsive design.

FUNCIONALIDADE DESEJADA:

1. **Tailwind Config:**
   ```typescript
   // tailwind.config.ts
   export default {
     content: ['./src/**/*.{tsx,ts}'],
     theme: {
       extend: {
         colors: {
           bg: {
             primary: '#0f172a',
             secondary: '#1e293b',
             tertiary: '#334155',
           },
           text: {
             primary: '#f1f1f1',
             secondary: '#cbd5e1',
             muted: '#94a3b8',
           },
           accent: {
             cyan: '#38bdf8',
             pink: '#ff006e',
             yellow: '#ffbe0b',
             purple: '#8338ec',
             green: '#06ffa5',
           },
         },
       },
     },
     plugins: [],
     darkMode: false, // Dark mode √© default, n√£o usar darkMode plugin
   };
   ```

2. **Global Styles:**
   ```css
   /* src/styles/globals.css */
   @tailwind base;
   @tailwind components;
   @tailwind utilities;

   html {
     @apply bg-bg-primary text-text-primary;
   }

   body {
     @apply bg-bg-primary text-text-primary font-sans;
   }

   button {
     @apply px-4 py-2 rounded bg-accent-cyan text-bg-primary hover:bg-accent-cyan/90 transition;
   }

   input, textarea, select {
     @apply bg-bg-secondary text-text-primary border border-bg-tertiary rounded px-3 py-2;
   }

   .page {
     @apply min-h-screen p-6;
   }

   .card {
     @apply bg-bg-secondary border border-bg-tertiary rounded-lg p-4;
   }
   ```

3. **Componentes com Tailwind:**
   - Navbar: dark background, clear buttons
   - Cards: dark backgrounds, subtle borders
   - Inputs: dark backgrounds, clear text
   - Buttons: accent colors, hover effects
   - Modals: dark overlays, dark content

INSTRU√á√ïES T√âCNICAS:

1. Instalar Tailwind (se ainda n√£o instalado):
   ```bash
   npm install -D tailwindcss postcss autoprefixer
   npx tailwindcss init -p
   ```

2. Configurar `tailwind.config.ts`:
   - Extend colors com palette de dark mode
   - Disable darkMode plugin (dark √© default)

3. Crie `src/styles/globals.css`.

4. Importe em `src/main.tsx`:
   ```typescript
   import './styles/globals.css'
   ```

5. Aplicar classes Tailwind em componentes:
   - `className="bg-bg-primary text-text-primary"`
   - `className="bg-accent-cyan hover:bg-accent-cyan/90"`
   - etc.

SA√çDA ESPERADA:
- `tailwind.config.ts` com cores dark mode
- `src/styles/globals.css` com estilos base
- Componentes com classes Tailwind
- Modo escuro consistente

CRIT√âRIOS DE ACEITE:
- [ ] Tailwind compilado sem erros.
- [ ] Modo escuro aplicado globalmente.
- [ ] Sem backgrounds brancos.
- [ ] Responsive design funciona.
- [ ] Hover/active states funcionam.

N√ÉO FAZER:
- N√£o usar white colors para backgrounds.
- N√£o usar dark mode plugin.
```

***

## Como Validar Localmente

Ap√≥s completar ETAPA 1-8, execute:

```bash
# 1. Type Check
npm run type-check
npm run lint

# 2. Testes
npm run test                    # Todos os testes
npm run test -- --coverage      # Com coverage

# 3. Build
npm run build

# 4. Dev Server (teste manual)
npm run dev
# Abrir http://localhost:5173
# Navegar entre todas as rotas
# Testar export/import
# Testar keyboard shortcuts (Ctrl+S, Escape, etc.)
```

***

## O que Deve Estar Acess√≠vel na UI ao Final

- ‚úÖ **Navega√ß√£o Completa:**
  - Navbar global com logo, bot√µes (Home, Graph, Export, Import, Settings)
  - Home page: lista de √°reas com cards
  - Area page: lista de conte√∫dos + mini-grafo
  - Content page: canvas editor + property sidebar + emoji picker
  - Graph page: grafo global com todos os n√≥s

- ‚úÖ **Interatividade:**
  - Criar √°rea (home page)
  - Criar conte√∫do (area page)
  - Editar conte√∫do (content page: canvas + propriedades)
  - Fechar conte√∫do (status = 'closed' ‚Üí aparece em grafo)
  - Deletar conte√∫do/√°rea (com confirma√ß√£o)
  - Navegar entre p√°ginas
  - Export/import .bound files
  - Settings modal

- ‚úÖ **Design & UX:**
  - Modo escuro em 100% da UI
  - Cores consistentes (ciano, verde, roxo, rosa, amarelo)
  - Responsive (mobile, tablet, desktop)
  - Hover/active states visuais
  - Loading indicators
  - Toasts de sucesso/erro

- ‚úÖ **Keyboard Shortcuts:**
  - Ctrl+S: export
  - Ctrl+E: emoji picker (context-dependent)
  - Escape: voltar/fechar modal
  - Del: deletar shapes/conte√∫dos (context-dependent)

- ‚úÖ **Persist√™ncia:**
  - Todas as a√ß√µes persistem em LocalStorage
  - Refresh mant√©m estado
  - Export/import funcional

***

## Pr√≥xima Fase (Teaser)

**Fase 5: Export/Import .bound & File Handling**  
Refinaremos o sistema de export/import com valida√ß√£o robusta, op√ß√µes de merge (adicionar novas √°reas vs substituir tudo), e feedback melhor. Implementaremos compress com gzip. Ao final: export/import profissional, com tratamento de erros e user feedback completo.
