# üìÑ FASE 6: E2E Testing & Deployment (Final)

## ESTRUTURA GERAL

A **Fase 6** completa a aplica√ß√£o com testes end-to-end profissionais, otimiza√ß√µes de performance, setup de CI/CD, e deployment para produ√ß√£o. Seu objetivo √© criar:

1. **E2E Tests com Playwright** cobrindo fluxos completos de usu√°rio
2. **Performance Testing & Optimization** com Lighthouse audits
3. **CI/CD Pipeline** com GitHub Actions para testes + build
4. **Containeriza√ß√£o com Docker** para consist√™ncia entre ambientes
5. **Deployment** para Vercel/Netlify com auto-deploy
6. **Monitoring & Analytics** b√°sicos (error tracking, performance)

Ao final da Fase 6, voc√™ ter√° uma **aplica√ß√£o profissional pronta para produ√ß√£o**, com cobertura de testes completa, deployment automatizado, e monitoring b√°sico.

***

## FASE 6: E2E Testing & Deployment (Final)

### ETAPA 1: Configurar Playwright & E2E Test Suite

**Objetivo:**  
Instalar Playwright e configurar infraestrutura para testes E2E.

**Arquivos principais a tocar:**
- `package.json`
- `playwright.config.ts` (novo)
- `e2e/` (diret√≥rio de testes)

**Prompt para IA:**

```text
Voc√™ √© um engenheiro de QA especializado em testes E2E com Playwright.

TAREFA:
Instalar e configurar Playwright para testes end-to-end da aplica√ß√£o BOUND.

CONTEXTO IMPORTANTE:
- Playwright: test runner multi-browser (Chrome, Firefox, Safari)
- Headless mode por padr√£o (sem UI)
- Integra√ß√£o com CI/CD (GitHub Actions)
- Sem flakiness: retry logic, proper waits

FUNCIONALIDADE DESEJADA:

1. **Instala√ß√£o:**
   - `npm install -D @playwright/test`
   - Playwright browsers ser√£o instalados automaticamente

2. **Configura√ß√£o (playwright.config.ts):**
   ```typescript
   import { defineConfig, devices } from '@playwright/test';

   export default defineConfig({
     testDir: './e2e',
     fullyParallel: true,
     forbidOnly: !!process.env.CI,
     retries: process.env.CI ? 2 : 0,
     workers: process.env.CI ? 1 : undefined,
     reporter: 'html',
     use: {
       baseURL: 'http://localhost:5173',
       trace: 'on-first-retry',
       screenshot: 'only-on-failure',
     },
     webServer: {
       command: 'npm run dev',
       url: 'http://localhost:5173',
       reuseExistingServer: !process.env.CI,
     },
     projects: [
       {
         name: 'chromium',
         use: { ...devices['Desktop Chrome'] },
       },
       {
         name: 'firefox',
         use: { ...devices['Desktop Firefox'] },
       },
       {
         name: 'webkit',
         use: { ...devices['Desktop Safari'] },
       },
     ],
   });
   ```

3. **Scripts (package.json):**
   ```json
   {
     "scripts": {
       "test:e2e": "playwright test",
       "test:e2e:ui": "playwright test --ui",
       "test:e2e:debug": "playwright test --debug"
     }
   }
   ```

4. **Exemplo de teste b√°sico (e2e/example.spec.ts):**
   ```typescript
   import { test, expect } from '@playwright/test';

   test('homepage loads', async ({ page }) => {
     await page.goto('/');
     await expect(page).toHaveTitle(/BOUND/);
   });
   ```

5. **Estrutura de diret√≥rios:**
   ```
   e2e/
   ‚îú‚îÄ‚îÄ auth/
   ‚îú‚îÄ‚îÄ content/
   ‚îú‚îÄ‚îÄ graph/
   ‚îú‚îÄ‚îÄ export-import/
   ‚îî‚îÄ‚îÄ fixtures.ts (helpers)
   ```

INSTRU√á√ïES T√âCNICAS:

1. Execute:
   ```bash
   npm install -D @playwright/test
   npx playwright install
   ```

2. Crie `playwright.config.ts`.

3. Crie `e2e/example.spec.ts`.

4. Teste:
   ```bash
   npm run test:e2e
   # Ou com UI:
   npm run test:e2e:ui
   ```

SA√çDA ESPERADA:
- Playwright instalado.
- `playwright.config.ts` configurado.
- `e2e/` com estrutura b√°sica.
- Exemplo de teste funcionando.

CRIT√âRIOS DE ACEITE:
- [ ] `npm install -D @playwright/test` sucede.
- [ ] `npx playwright test` roda sem erros.
- [ ] Exemplo teste passa.
- [ ] UI mode (`--ui`) funciona.

N√ÉO FAZER:
- N√£o usar Cypress (j√° escolhemos Playwright).
```

***

### ETAPA 2: Implementar E2E Tests para Fluxos Cr√≠ticos

**Objetivo:**  
Criar suite de testes E2E cobrindo fluxos de usu√°rio cr√≠ticos (CRUD, export/import, grafo).

**Arquivos principais a tocar:**
- `e2e/auth/home.spec.ts`
- `e2e/content/create-edit-delete.spec.ts`
- `e2e/graph/navigation.spec.ts`
- `e2e/export-import/export-import.spec.ts`
- `e2e/fixtures.ts` (helpers)

**Prompt para IA:**

```text
Voc√™ √© um expert em testes E2E com Playwright.

TAREFA:
Implementar suite de testes E2E cobrindo fluxos cr√≠ticos da aplica√ß√£o BOUND.

CONTEXTO IMPORTANTE:
- Fluxos cr√≠ticos: home ‚Üí create area ‚Üí create content ‚Üí edit canvas ‚Üí close ‚Üí grafo ‚Üí export/import
- Cada teste deve ser independente (sem dependencies entre testes)
- Use fixtures para setup/teardown comum
- Sem flakiness: proper waits, retries

FUNCIONALIDADE DESEJADA:

1. **Fixtures (e2e/fixtures.ts):**
   ```typescript
   import { test as base } from '@playwright/test';

   export const test = base.extend({
     // Fixture: page com localStorage limpo
     cleanPage: async ({ page }, use) => {
       await page.context().clearCookies();
       await page.evaluate(() => localStorage.clear());
       await page.goto('/');
       await use(page);
     },

     // Fixture: criar area base
     areaWithContent: async ({ cleanPage }, use) => {
       await cleanPage.click('button:has-text("New Area")');
       await cleanPage.fill('input[placeholder="Area name"]', 'Test Area');
       await cleanPage.click('button:has-text("Create")');
       await use(cleanPage);
     },
   });
   ```

2. **Home Page Tests (e2e/auth/home.spec.ts):**
   ```typescript
   import { test, expect } from '../fixtures';

   test('should load home page', async ({ cleanPage }) => {
     await expect(cleanPage.locator('h1:has-text("Your Areas")')).toBeVisible();
   });

   test('should create new area', async ({ cleanPage }) => {
     await cleanPage.click('button:has-text("New Area")');
     await cleanPage.fill('input[placeholder="Area name"]', 'Test Area');
     await cleanPage.click('button:has-text("Create")');
     
     await expect(cleanPage.locator('text=Test Area')).toBeVisible();
   });

   test('should navigate to area', async ({ cleanPage }) => {
     // Create area
     await cleanPage.click('button:has-text("New Area")');
     await cleanPage.fill('input[placeholder="Area name"]', 'Test Area');
     await cleanPage.click('button:has-text("Create")');
     
     // Click area card
     await cleanPage.click('text=Test Area');
     
     // Should navigate to /area/:id
     await expect(cleanPage).toHaveURL(/\/area\//);
   });
   ```

3. **Content Tests (e2e/content/create-edit-delete.spec.ts):**
   ```typescript
   import { test, expect } from '../fixtures';

   test('should create content in area', async ({ areaWithContent }) => {
     const page = areaWithContent;
     
     await page.click('button:has-text("New Content")');
     await page.fill('input[placeholder="Content title"]', 'Test Content');
     await page.click('button:has-text("Create")');
     
     await expect(page.locator('text=Test Content')).toBeVisible();
   });

   test('should open content editor', async ({ areaWithContent }) => {
     const page = areaWithContent;
     
     // Create content
     await page.click('button:has-text("New Content")');
     await page.fill('input[placeholder="Content title"]', 'Test Content');
     await page.click('button:has-text("Create")');
     
     // Click content
     await page.click('text=Test Content');
     
     // Should navigate to /content/:id and show canvas
     await expect(page).toHaveURL(/\/content\//);
     await expect(page.locator('.canvas-editor')).toBeVisible();
   });

   test('should close content', async ({ areaWithContent }) => {
     const page = areaWithContent;
     
     // Create and open content
     await page.click('button:has-text("New Content")');
     await page.fill('input[placeholder="Content title"]', 'Test Content');
     await page.click('button:has-text("Create")');
     await page.click('text=Test Content');
     
     // Close content
     await page.click('button:has-text("Close Content")');
     
     // Should go back to area page
     await expect(page).toHaveURL(/\/area\//);
   });

   test('should delete content', async ({ areaWithContent }) => {
     const page = areaWithContent;
     
     // Create and open content
     await page.click('button:has-text("New Content")');
     await page.fill('input[placeholder="Content title"]', 'Test Content');
     await page.click('button:has-text("Create")');
     await page.click('text=Test Content');
     
     // Delete content
     await page.click('button:has-text("Delete")');
     await page.click('button:has-text("OK")'); // confirmation
     
     // Should go back and content should be gone
     await expect(page).toHaveURL(/\/area\//);
     await expect(page.locator('text=Test Content')).not.toBeVisible();
   });
   ```

4. **Canvas Editor Tests (e2e/content/canvas.spec.ts):**
   ```typescript
   import { test, expect } from '../fixtures';

   test('should draw rectangle on canvas', async ({ areaWithContent }) => {
     const page = areaWithContent;
     
     // Create and open content
     await page.click('button:has-text("New Content")');
     await page.fill('input[placeholder="Content title"]', 'Test Content');
     await page.click('button:has-text("Create")');
     await page.click('text=Test Content');
     
     // Select rectangle tool
     await page.click('button[data-tool="rect"]');
     
     // Draw on canvas
     const canvas = page.locator('.canvas-editor canvas').first();
     await canvas.click({ position: { x: 100, y: 100 } });
     await canvas.dragTo(canvas, {
       sourcePosition: { x: 100, y: 100 },
       targetPosition: { x: 200, y: 200 },
     });
     
     // Should see shape on canvas
     // (verifica√ß√£o visual complexa; simplificar)
   });

   test('should undo draw action', async ({ areaWithContent }) => {
     const page = areaWithContent;
     
     // Create and open content
     // Draw shape
     // Ctrl+Z
     await page.keyboard.press('Control+Z');
     
     // Shape should be gone (verificar via count de shapes)
   });
   ```

5. **Graph Tests (e2e/graph/navigation.spec.ts):**
   ```typescript
   import { test, expect } from '../fixtures';

   test('should navigate to graph page', async ({ cleanPage }) => {
     await cleanPage.click('button:has-text("Graph")');
     await expect(cleanPage).toHaveURL('/graph');
     await expect(cleanPage.locator('.graph-page')).toBeVisible();
   });

   test('should show nodes in graph after closing content', async ({ areaWithContent }) => {
     const page = areaWithContent;
     
     // Create and close content
     await page.click('button:has-text("New Content")');
     await page.fill('input[placeholder="Content title"]', 'Test Content');
     await page.click('button:has-text("Create")');
     await page.click('text=Test Content');
     await page.click('button:has-text("Close Content")');
     
     // Navigate to graph
     await page.click('button:has-text("Graph")');
     
     // Should show node
     await expect(page.locator('.cytoscape-container')).toBeVisible();
     // Check for node (simplificar, pode ser complexo)
   });
   ```

6. **Export/Import Tests (e2e/export-import/export-import.spec.ts):**
   ```typescript
   import { test, expect } from '../fixtures';
   import path from 'path';

   test('should export state to file', async ({ cleanPage }) => {
     // Create area + content
     await cleanPage.click('button:has-text("New Area")');
     await cleanPage.fill('input[placeholder="Area name"]', 'Test Area');
     await cleanPage.click('button:has-text("Create")');
     
     // Export
     const downloadPromise = cleanPage.waitForEvent('download');
     await cleanPage.click('button:has-text("Export")');
     const download = await downloadPromise;
     
     // Verify file
     expect(download.suggestedFilename()).toMatch(/^bound-\d{4}-\d{2}-\d{2}\.bound$/);
   });

   test('should import state from file', async ({ cleanPage }) => {
     // Export first
     // (criar arquivo de teste)
     
     // Import
     await cleanPage.click('button:has-text("Import")');
     // Selecionar arquivo
     // Wizard steps
     
     // Verify data imported
   });

   test('should merge on import', async ({ cleanPage }) => {
     // Create area 1
     // Export
     // Create area 2
     // Import (merge strategy)
     // Should have both areas
   });
   ```

INSTRU√á√ïES T√âCNICAS:

1. Crie `e2e/fixtures.ts`.

2. Crie `e2e/auth/home.spec.ts`.

3. Crie `e2e/content/create-edit-delete.spec.ts`.

4. Crie `e2e/content/canvas.spec.ts`.

5. Crie `e2e/graph/navigation.spec.ts`.

6. Crie `e2e/export-import/export-import.spec.ts`.

7. Rodar:
   ```bash
   npm run test:e2e
   ```

SA√çDA ESPERADA:
- E2E tests para fluxos cr√≠ticos
- Testes passando
- HTML report gerado

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test:e2e` passa.
- [ ] M√≠nimo 10 testes E2E.
- [ ] Coverage de fluxos cr√≠ticos.
- [ ] Sem flakiness (testes consistentes).
- [ ] Report HTML gerado.

N√ÉO FAZER:
- N√£o fazer testes muito detalhados (visuais).
- N√£o testar cada pixel (flaky).
```

***

### ETAPA 3: Implementar Performance Testing & Lighthouse

**Objetivo:**  
Configurar performance audits e testes de performance com Lighthouse.

**Arquivos principais a tocar:**
- `e2e/performance/performance.spec.ts`
- `scripts/lighthouse.js` (opcional)
- `lighthouse.config.js` (novo)

**Prompt para IA:**

```text
Voc√™ √© um expert em web performance e Lighthouse audits.

TAREFA:
Implementar performance testing com Lighthouse e m√©tricas de performance nos E2E tests.

CONTEXTO IMPORTANTE:
- Lighthouse: audita performance, acessibilidade, best practices, SEO
- M√©tricas: FCP, LCP, CLS, TTI
- Budget de performance: estabelecer targets
- CI: falhar se performance cair abaixo do threshold

FUNCIONALIDADE DESEJADA:

1. **Performance Test (e2e/performance/performance.spec.ts):**
   ```typescript
   import { test, expect } from '@playwright/test';

   test('homepage should meet performance targets', async ({ page }) => {
     await page.goto('/');
     
     // Medir Core Web Vitals
     const metrics = await page.evaluate(() => {
       const paint = performance.getEntriesByType('paint');
       const navigation = performance.getEntriesByType('navigation');
       
       return {
         // First Contentful Paint
         fcp: paint.find((p) => p.name === 'first-contentful-paint')?.startTime ?? 0,
         // Largest Contentful Paint (aproxima√ß√£o)
         lcp: 0, // Require PerformanceObserver
         // Cumulative Layout Shift (aproxima√ß√£o)
         cls: 0,
       };
     });
     
     // Targets (em ms)
     expect(metrics.fcp).toBeLessThan(1800); // Good: <1.8s
   });

   test('should not have memory leaks', async ({ page }) => {
     await page.goto('/');
     
     // Navigate multiple times
     for (let i = 0; i < 10; i++) {
       await page.click('button:has-text("Home")');
       await page.click('button:has-text("Graph")');
     }
     
     // Check memory (aproximado, sem acesso direto)
     // Pode usar CDP para metrics mais precisas
   });

   test('should handle 100+ nodes in graph', async ({ page }) => {
     await page.goto('/');
     
     // Create many areas
     for (let i = 0; i < 20; i++) {
       await page.click('button:has-text("New Area")');
       await page.fill('input[placeholder="Area name"]', `Area ${i}`);
       await page.click('button:has-text("Create")');
       // Go back
       await page.click('button:has-text("Home")');
     }
     
     // Navigate to graph
     await page.click('button:has-text("Graph")');
     
     // Should render in <2s
     const startTime = Date.now();
     await page.locator('.cytoscape-container').waitFor({ state: 'visible' });
     const renderTime = Date.now() - startTime;
     
     expect(renderTime).toBeLessThan(2000);
   });
   ```

2. **Lighthouse Config (lighthouse.config.js):**
   ```javascript
   module.exports = {
     ci: {
       collect: {
         url: ['http://localhost:5173/'],
         numberOfRuns: 3,
         settings: {
           configPath: './lighthouse.config.json',
         },
       },
       assert: {
         preset: 'lighthouse:recommended',
         assertions: {
           'categories:performance': ['error', { minScore: 0.85 }],
           'categories:accessibility': ['error', { minScore: 0.90 }],
           'categories:best-practices': ['error', { minScore: 0.85 }],
         },
       },
       upload: {
         target: 'temporary-public-storage',
       },
     },
   };
   ```

3. **Performance Script (scripts/lighthouse.js):**
   ```javascript
   const lighthouse = require('lighthouse');
   const chromeLauncher = require('chrome-launcher');

   (async () => {
     let chrome;
     try {
       chrome = await chromeLauncher.launch({ chromeFlags: ['--headless'] });
       const options = {
         logLevel: 'info',
         output: 'json',
         port: chrome.port,
       };
       const runnerResult = await lighthouse('http://localhost:5173', options);
       console.log(JSON.stringify(runnerResult.lhr, null, 2));
     } finally {
       await chrome.kill();
     }
   })();
   ```

4. **Scripts (package.json):**
   ```json
   {
     "scripts": {
       "test:perf": "playwright test --grep @perf",
       "test:lighthouse": "node scripts/lighthouse.js"
     }
   }
   ```

INSTRU√á√ïES T√âCNICAS:

1. Instalar Lighthouse:
   ```bash
   npm install -D lighthouse chrome-launcher
   ```

2. Crie `e2e/performance/performance.spec.ts`.

3. Crie `lighthouse.config.js`.

4. Crie `scripts/lighthouse.js`.

5. Rodar:
   ```bash
   npm run test:perf
   npm run test:lighthouse
   ```

SA√çDA ESPERADA:
- Performance tests
- Lighthouse config
- Scripts funcionando
- Reports gerados

CRIT√âRIOS DE ACEITE:
- [ ] Performance tests rodam.
- [ ] Lighthouse audits passam.
- [ ] Performance targets atingidos.
- [ ] Reports gerados e analis√°veis.

N√ÉO FAZER:
- N√£o fazer performance tuning ainda (Fase 6+).
```

***

### ETAPA 4: Configurar CI/CD com GitHub Actions

**Objetivo:**  
Configurar pipeline CI/CD que roda testes, build, e deploy automaticamente.

**Arquivos principais a tocar:**
- `.github/workflows/ci.yml` (novo)
- `.github/workflows/deploy.yml` (novo)

**Prompt para IA:**

```text
Voc√™ √© um DevOps engineer especializado em GitHub Actions e CI/CD.

TAREFA:
Configurar pipeline CI/CD com GitHub Actions para testes, build, e deploy.

CONTEXTO IMPORTANTE:
- CI: rodar testes (unit + E2E) a cada push/PR
- Build: build app a cada push
- Deploy: deploy para Vercel/Netlify a cada merge para main
- Artifacts: salvar build artifacts
- Reports: gerar e reportar coverage/performance

FUNCIONALIDADE DESEJADA:

1. **CI Workflow (.github/workflows/ci.yml):**
   ```yaml
   name: CI

   on:
     push:
       branches: [main, develop]
     pull_request:
       branches: [main, develop]

   jobs:
     test:
       runs-on: ubuntu-latest
       strategy:
         matrix:
           node-version: [18.x, 20.x]

       steps:
         - uses: actions/checkout@v3

         - name: Install Node
           uses: actions/setup-node@v3
           with:
             node-version: ${{ matrix.node-version }}
             cache: 'npm'

         - name: Install dependencies
           run: npm ci

         - name: Type check
           run: npm run type-check

         - name: Lint
           run: npm run lint

         - name: Unit tests
           run: npm run test -- --coverage

         - name: Upload coverage
           uses: codecov/codecov-action@v3
           with:
             files: ./coverage/lcov.info

     e2e:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v3

         - name: Install Node
           uses: actions/setup-node@v3
           with:
             node-version: 20.x
             cache: 'npm'

         - name: Install dependencies
           run: npm ci

         - name: Install Playwright browsers
           run: npx playwright install --with-deps

         - name: Build
           run: npm run build

         - name: E2E tests
           run: npm run test:e2e

         - name: Upload E2E report
           if: always()
           uses: actions/upload-artifact@v3
           with:
             name: playwright-report
             path: playwright-report/
             retention-days: 30

     build:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v3

         - name: Install Node
           uses: actions/setup-node@v3
           with:
             node-version: 20.x
             cache: 'npm'

         - name: Install dependencies
           run: npm ci

         - name: Build
           run: npm run build

         - name: Upload build artifacts
           uses: actions/upload-artifact@v3
           with:
             name: dist
             path: dist/
             retention-days: 7
   ```

2. **Deploy Workflow (.github/workflows/deploy.yml):**
   ```yaml
   name: Deploy

   on:
     push:
       branches: [main]

   jobs:
     deploy:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v3

         - name: Install Node
           uses: actions/setup-node@v3
           with:
             node-version: 20.x
             cache: 'npm'

         - name: Install dependencies
           run: npm ci

         - name: Build
           run: npm run build

         - name: Deploy to Vercel
           uses: vercel/action@v4
           with:
             vercel-token: ${{ secrets.VERCEL_TOKEN }}
             vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
             vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
             production: true
           env:
             VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
             VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
             VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
   ```

3. **Secrets Setup (manual no GitHub):**
   - `VERCEL_TOKEN`: token from vercel.com/account/tokens
   - `VERCEL_ORG_ID`: org ID from Vercel
   - `VERCEL_PROJECT_ID`: project ID from Vercel
   - `CODECOV_TOKEN`: token from codecov.io

INSTRU√á√ïES T√âCNICAS:

1. Crie `.github/workflows/ci.yml`.

2. Crie `.github/workflows/deploy.yml`.

3. Setup Vercel (optional, pode usar Netlify):
   ```bash
   npm i -g vercel
   vercel
   # Segue prompts para setup
   ```

4. Adicionar secrets no GitHub:
   - Settings ‚Üí Secrets and variables ‚Üí Actions
   - Adicionar VERCEL_TOKEN, etc

5. Push para GitHub:
   ```bash
   git add .github/
   git commit -m "chore: add CI/CD workflows"
   git push
   ```

SA√çDA ESPERADA:
- `.github/workflows/ci.yml`
- `.github/workflows/deploy.yml`
- Workflows rodando automaticamente

CRIT√âRIOS DE ACEITE:
- [ ] Workflows disparados a cada push.
- [ ] Testes rodam no CI.
- [ ] Build sucede.
- [ ] Deploy acontece para main.
- [ ] Artifacts salvos.
- [ ] Reports gerados (coverage, E2E).

N√ÉO FAZER:
- N√£o committar secrets (use GitHub secrets).
```

***

### ETAPA 5: Containerizar com Docker

**Objetivo:**  
Criar Dockerfile para containerizar aplica√ß√£o para deployment consistente.

**Arquivos principais a tocar:**
- `Dockerfile` (novo)
- `.dockerignore` (novo)
- `docker-compose.yml` (opcional)

**Prompt para IA:**

```text
Voc√™ √© um DevOps engineer especializado em Docker e containeriza√ß√£o.

TAREFA:
Criar Dockerfile para containerizar aplica√ß√£o BOUND para produ√ß√£o.

CONTEXTO IMPORTANTE:
- Multi-stage build: minimize image size
- Production mode: build app, serve com nginx/node
- Health check: verificar se container est√° healthy
- Security: run as non-root user

FUNCIONALIDADE DESEJADA:

1. **Dockerfile (multi-stage):**
   ```dockerfile
   # Stage 1: Build
   FROM node:20-alpine AS builder

   WORKDIR /app

   COPY package*.json ./
   RUN npm ci

   COPY . .
   RUN npm run build

   # Stage 2: Runtime
   FROM node:20-alpine

   WORKDIR /app

   # Security: create non-root user
   RUN addgroup -g 1001 -S nodejs && adduser -S nextjs -u 1001

   # Install serve para servir app (ou usar Node.js)
   RUN npm install -g serve

   # Copy build output
   COPY --from=builder /app/dist ./dist
   COPY --from=builder /app/package*.json ./

   # Security
   USER nextjs

   # Health check
   HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
     CMD curl -f http://localhost:3000/ || exit 1

   EXPOSE 3000

   CMD ["serve", "-s", "dist", "-l", "3000"]
   ```

2. **.dockerignore:**
   ```
   node_modules
   npm-debug.log
   dist
   build
   .git
   .gitignore
   .env.local
   .env.*.local
   coverage
   e2e/
   .github/
   docs/
   ```

3. **docker-compose.yml (opcional):**
   ```yaml
   version: '3.8'

   services:
     bound:
       build: .
       ports:
         - "3000:3000"
       environment:
         - NODE_ENV=production
       healthcheck:
         test: ["CMD", "curl", "-f", "http://localhost:3000"]
         interval: 30s
         timeout: 10s
         retries: 3
         start_period: 5s
   ```

4. **Build & Run Local:**
   ```bash
   # Build image
   docker build -t bound:latest .

   # Run container
   docker run -p 3000:3000 bound:latest

   # Or with docker-compose
   docker-compose up
   ```

INSTRU√á√ïES T√âCNICAS:

1. Crie `Dockerfile`.

2. Crie `.dockerignore`.

3. Crie `docker-compose.yml` (opcional).

4. Teste local:
   ```bash
   docker build -t bound:latest .
   docker run -p 3000:3000 bound:latest
   # Abrir http://localhost:3000
   ```

5. Push para registry (DockerHub, GitHub Packages, etc):
   ```bash
   docker tag bound:latest seu-username/bound:latest
   docker push seu-username/bound:latest
   ```

SA√çDA ESPERADA:
- `Dockerfile` multi-stage
- `.dockerignore`
- `docker-compose.yml`
- Image pode ser buildada e rodada

CRIT√âRIOS DE ACEITE:
- [ ] `docker build` sucede.
- [ ] `docker run` funciona.
- [ ] App acess√≠vel em http://localhost:3000.
- [ ] Health check passa.
- [ ] Image √© <200MB.

N√ÉO FAZER:
- N√£o incluir secrets em image.
```

***

### ETAPA 6: Setup Deployment (Vercel/Netlify)

**Objetivo:**  
Configurar deployment automatizado para Vercel ou Netlify.

**Arquivos principais a tocar:**
- `vercel.json` (novo, se usando Vercel)
- `netlify.toml` (novo, se usando Netlify)

**Prompt para IA:**

```text
Voc√™ √© um DevOps engineer especializado em serverless deployment.

TAREFA:
Configurar deployment automatizado para Vercel ou Netlify com auto-deploy na main branch.

CONTEXTO IMPORTANTE:
- Vercel: otimizado para Next.js mas suporta Vite
- Netlify: gen√©rico, suporta qualquer SPA
- Auto-deploy: merge para main dispara deploy
- Preview: PRs geram URLs de preview
- Env vars: configurar para produ√ß√£o

FUNCIONALIDADE DESEJADA:

1. **Vercel Config (vercel.json):**
   ```json
   {
     "buildCommand": "npm run build",
     "devCommand": "npm run dev",
     "installCommand": "npm install",
     "outputDirectory": "dist",
     "env": {
       "NODE_ENV": "production"
     }
   }
   ```

2. **Netlify Config (netlify.toml):**
   ```toml
   [build]
     command = "npm run build"
     publish = "dist"
     environment = { NODE_VERSION = "20.x" }

   [context.production]
     environment = { NODE_ENV = "production" }

   [[redirects]]
     from = "/*"
     to = "/index.html"
     status = 200

   [[headers]]
     for = "/assets/*"
     [headers.values]
       Cache-Control = "public, max-age=31536000, immutable"
   ```

3. **Setup Manual:**

   **Vercel:**
   ```bash
   npm i -g vercel
   vercel --prod
   # Segue prompts
   # Depois, no GitHub repo Settings:
   # - Add VERCEL_TOKEN, VERCEL_ORG_ID, VERCEL_PROJECT_ID secrets
   ```

   **Netlify:**
   ```bash
   npm i -g netlify-cli
   netlify init
   # Segue prompts
   # Depois, no GitHub repo Settings:
   # - Add NETLIFY_AUTH_TOKEN secret (opcional, pode usar Netlify UI)
   ```

4. **Environment Variables (Production):**
   - No Vercel/Netlify dashboard, adicionar env vars se necess√°rio:
     - `VITE_API_URL`: (se tiver API backend)
     - etc

INSTRU√á√ïES T√âCNICAS:

1. Escolher: Vercel ou Netlify.

2. Se Vercel:
   - Crie `vercel.json`
   - Setup via `vercel` CLI
   - Configure secrets no GitHub

3. Se Netlify:
   - Crie `netlify.toml`
   - Setup via `netlify` CLI
   - Configure secrets

4. Testar:
   - Push para GitHub main
   - Workflow dispara
   - Deploy acontece
   - App acess√≠vel em URL p√∫blica

SA√çDA ESPERADA:
- `vercel.json` ou `netlify.toml`
- Deployment configurado
- Auto-deploy funcionando
- Preview URLs para PRs

CRIT√âRIOS DE ACEITE:
- [ ] Deploy sucede ap√≥s push.
- [ ] App acess√≠vel em URL p√∫blica.
- [ ] Preview URLs geram para PRs.
- [ ] Env vars configuradas.

N√ÉO FAZER:
- N√£o committar secrets.
```

***

### ETAPA 7: Implementar Monitoring & Error Tracking

**Objetivo:**  
Configurar monitoramento b√°sico de erros e analytics com ferramentas como Sentry, LogRocket, ou simples log collection.

**Arquivos principais a tocar:**
- `src/utils/monitoring/errorTracking.ts` (novo)
- `src/utils/monitoring/analytics.ts` (novo)

**Prompt para IA:**

```text
Voc√™ √© um engenheiro especializado em observabilidade e monitoring.

TAREFA:
Implementar monitoramento b√°sico de erros e analytics para a aplica√ß√£o BOUND.

CONTEXTO IMPORTANTE:
- Sentry: error tracking profissional (free tier)
- LogRocket: session replay + error tracking
- Alternativa simples: logs locais no localStorage
- Analytics: rastrear user flows, erros, performance

FUNCIONALIDADE DESEJADA:

1. **Error Tracking (Sentry - simples integra√ß√£o):**
   ```typescript
   // src/utils/monitoring/errorTracking.ts
   import * as Sentry from "@sentry/react";

   export function initErrorTracking() {
     if (process.env.NODE_ENV === 'production') {
       Sentry.init({
         dsn: process.env.VITE_SENTRY_DSN,
         environment: process.env.NODE_ENV,
         tracesSampleRate: 0.1,
         replaysSessionSampleRate: 0.1,
         replaysOnErrorSampleRate: 1.0,
         integrations: [
           new Sentry.Replay({ maskAllText: true, blockAllMedia: true }),
         ],
       });
     }
   }

   export function captureException(error: unknown, context?: Record<string, any>) {
     Sentry.captureException(error, { contexts: { custom: context } });
   }

   export function captureMessage(message: string, level: Sentry.SeverityLevel = 'info') {
     Sentry.captureMessage(message, level);
   }
   ```

2. **Analytics (simples - localStorage based):**
   ```typescript
   // src/utils/monitoring/analytics.ts
   export interface AnalyticsEvent {
     name: string;
     timestamp: number;
     data?: Record<string, any>;
   }

   export class Analytics {
     private static readonly STORAGE_KEY = 'bound_analytics';

     static logEvent(name: string, data?: Record<string, any>) {
       const event: AnalyticsEvent = {
         name,
         timestamp: Date.now(),
         data,
       };

       // Log to console
       console.log('[Analytics]', event);

       // Store in localStorage
       try {
         const events = JSON.parse(localStorage.getItem(this.STORAGE_KEY) || '[]');
         events.push(event);
         // Keep only last 100 events
         if (events.length > 100) {
           events.shift();
         }
         localStorage.setItem(this.STORAGE_KEY, JSON.stringify(events));
       } catch (err) {
         console.error('Failed to log analytics event:', err);
       }

       // Opcionalmente, enviar para Sentry
       Sentry.captureMessage(`Event: ${name}`, 'info');
     }

     static getEvents(): AnalyticsEvent[] {
       try {
         return JSON.parse(localStorage.getItem(this.STORAGE_KEY) || '[]');
       } catch (err) {
         return [];
       }
     }

     static clearEvents() {
       localStorage.removeItem(this.STORAGE_KEY);
     }
   }

   // Common events
   export const EVENTS = {
     APP_STARTED: 'app_started',
     AREA_CREATED: 'area_created',
     CONTENT_CREATED: 'content_created',
     CONTENT_CLOSED: 'content_closed',
     EXPORT_STARTED: 'export_started',
     EXPORT_COMPLETED: 'export_completed',
     IMPORT_STARTED: 'import_started',
     IMPORT_COMPLETED: 'import_completed',
     ERROR: 'error',
   };
   ```

3. **Integra√ß√£o em App.tsx:**
   ```typescript
   import { initErrorTracking } from './utils/monitoring/errorTracking';
   import { Analytics, EVENTS } from './utils/monitoring/analytics';

   // Init monitoring
   initErrorTracking();

   export default function App() {
     useEffect(() => {
       Analytics.logEvent(EVENTS.APP_STARTED);
     }, []);

     return <RouterProvider router={router} />;
   }
   ```

4. **Error Boundary (React):**
   ```typescript
   import * as Sentry from "@sentry/react";

   const SentryErrorBoundary = Sentry.withErrorBoundary(
     YourApp,
     {
       fallback: <h2>Something went wrong. Please refresh the page.</h2>,
       showDialog: process.env.NODE_ENV === 'production',
     }
   );
   ```

5. **Setup Sentry (opcional):**
   ```bash
   npm install @sentry/react @sentry/tracing

   # Setup no .env.production.local:
   VITE_SENTRY_DSN=https://...@sentry.io/...
   ```

INSTRU√á√ïES T√âCNICAS:

1. Op√ß√£o A (Sentry):
   - Criar conta em sentry.io (free)
   - Criar projeto React
   - Copiar DSN
   - `npm install @sentry/react @sentry/tracing`
   - Implementar integra√ß√£o

2. Op√ß√£o B (Simples):
   - Usar apenas localStorage-based analytics
   - N√£o instalar Sentry
   - Simplificar errorTracking.ts

3. Crie `src/utils/monitoring/errorTracking.ts`.

4. Crie `src/utils/monitoring/analytics.ts`.

5. Integre em App.tsx.

6. Teste:
   - Usar console para ver events
   - Verificar localStorage
   - (Se Sentry) verificar dashboard

SA√çDA ESPERADA:
- `src/utils/monitoring/errorTracking.ts`
- `src/utils/monitoring/analytics.ts`
- Integra√ß√£o em App
- Error boundary
- Events sendo tracked

CRIT√âRIOS DE ACEITE:
- [ ] Events logged corretamente.
- [ ] Errors captured.
- [ ] localStorage populated.
- [ ] (Se Sentry) dashboard shows events.

N√ÉO FAZER:
- N√£o fazer tracking complexo (simples √© ok).
```

***

### ETAPA 8: Documenta√ß√£o de Deployment & Finaliza√ß√µes

**Objetivo:**  
Criar documenta√ß√£o completa de deployment, troubleshooting, e contribui√ß√£o.

**Arquivos principais a tocar:**
- `docs/DEPLOYMENT.md` (novo)
- `docs/CONTRIBUTING.md` (novo)
- `docs/TROUBLESHOOTING.md` (novo)
- `README.md` (finalizar)

**Prompt para IA:**

```text
Voc√™ √© um technical writer especializado em documenta√ß√£o de software.

TAREFA:
Criar documenta√ß√£o completa de deployment, contributing, troubleshooting, e finaliza√ß√µes.

CONTEXTO IMPORTANTE:
- DEPLOYMENT.md: guia de deploy local, CI/CD, Docker
- CONTRIBUTING.md: guia para contribuidores
- TROUBLESHOOTING.md: common issues e solu√ß√µes
- README.md: finaliza√ß√µes e overview

FUNCIONALIDADE DESEJADA:

1. **DEPLOYMENT.md:**
   ```markdown
   # Deployment Guide

   ## Local Development

   ```bash
   npm install
   npm run dev
   # http://localhost:5173
   ```

   ## Production Build

   ```bash
   npm run build
   npm run preview  # Visualizar build localmente
   ```

   ## Docker

   ```bash
   docker build -t bound:latest .
   docker run -p 3000:3000 bound:latest
   # http://localhost:3000
   ```

   ## Vercel

   ```bash
   npm i -g vercel
   vercel --prod
   ```

   ## Netlify

   ```bash
   npm i -g netlify-cli
   netlify init
   netlify deploy --prod
   ```

   ## Environment Variables

   - `VITE_SENTRY_DSN` (optional): Sentry DSN for error tracking
   - `VITE_API_URL` (optional): API endpoint if using backend

   ## Monitoring

   - Sentry: https://sentry.io/ (error tracking)
   - Vercel/Netlify: built-in analytics
   ```

2. **CONTRIBUTING.md:**
   ```markdown
   # Contributing Guide

   ## Setup

   ```bash
   git clone https://github.com/yourusername/bound.git
   cd bound
   npm install
   npm run dev
   ```

   ## Development

   - All code in `src/`
   - Tests in `tests/` (unit) and `e2e/` (E2E)
   - Run: `npm run dev`
   - Test: `npm run test`
   - Lint: `npm run lint`

   ## Committing

   - Use conventional commits: `feat:`, `fix:`, `docs:`, etc
   - `git commit -m "feat: add new feature"`
   - PRs must pass CI

   ## Code Quality

   - ESLint: `npm run lint`
   - TypeScript: `npm run type-check`
   - Tests: `npm run test` (>85% coverage)
   - E2E: `npm run test:e2e`

   ## Phases

   - Phase 1: Core Data Model & Storage
   - Phase 2: Canvas Editor (Quadro Negro)
   - Phase 3: Graph Visualization & Rendering
   - Phase 4: UI Navigation & Routing
   - Phase 5: Export/Import & File Handling
   - Phase 6: E2E Testing & Deployment

   See `docs/PHASES.md` for details.
   ```

3. **TROUBLESHOOTING.md:**
   ```markdown
   # Troubleshooting

   ## Common Issues

   ### Build fails with memory error
   - Increase Node memory: `NODE_OPTIONS=--max-old-space-size=4096 npm run build`

   ### Tests are flaky
   - E2E tests may be flaky due to timing
   - Run tests locally: `npm run test:e2e --debug`
   - Check for missing waits: `page.waitFor()`

   ### Docker image too large
   - Use multi-stage build (already in Dockerfile)
   - Remove unnecessary dependencies

   ### Deployment fails
   - Check CI/CD logs: GitHub Actions dashboard
   - Verify env vars configured in Vercel/Netlify
   - Check build command succeeds locally

   ### App slow in production
   - Check Lighthouse audit: `npm run test:lighthouse`
   - Profile with DevTools
   - Check bundle size: `npm run build -- --stats`
   ```

4. **README.md (finalizar):**
   ```markdown
   # BOUND - Knowledge Graph Application

   ## Overview

   BOUND is a knowledge management application that helps you organize, visualize, and share information through interconnected nodes (contents) and links in a graph structure.

   - üìù **Canvas Editor**: Draw shapes, add properties, organize content visually
   - üîó **Graph Visualization**: See all connections between contents at a glance
   - üíæ **Export/Import**: Save and restore your knowledge base as .bound files
   - üåô **Dark Mode**: Beautiful dark UI optimized for long working sessions
   - üì± **Responsive**: Works on desktop, tablet, and mobile

   ## Getting Started

   ### Installation

   ```bash
   npm install
   npm run dev
   ```

   ### Features

   - Create areas to organize your knowledge
   - Add contents to areas
   - Edit contents with a visual canvas editor
   - Draw shapes, add properties, link contents
   - Visualize everything in a dynamic graph
   - Export your knowledge base to .bound files
   - Import and merge external knowledge bases

   ## Documentation

   - [Getting Started](docs/GETTING_STARTED.md)
   - [User Guide](docs/USER_GUIDE.md)
   - [Deployment](docs/DEPLOYMENT.md)
   - [Contributing](docs/CONTRIBUTING.md)
   - [Troubleshooting](docs/TROUBLESHOOTING.md)

   ## Architecture

   - **Frontend**: React 18 + TypeScript
   - **Canvas**: Konva.js (shape rendering and editing)
   - **Graph**: Cytoscape.js (graph visualization)
   - **Routing**: React Router
   - **State Management**: Zustand
   - **Storage**: LocalStorage + export/import

   ## Testing

   - Unit: Vitest
   - E2E: Playwright
   - Coverage: >85%

   ## Deployment

   - Vercel: `npm run build` ‚Üí push to main
   - Netlify: `npm run build` ‚Üí push to main
   - Docker: `docker build -t bound:latest .`

   ## License

   MIT

   ## Contributing

   See [CONTRIBUTING.md](docs/CONTRIBUTING.md)
   ```

INSTRU√á√ïES T√âCNICAS:

1. Crie `docs/DEPLOYMENT.md`.

2. Crie `docs/CONTRIBUTING.md`.

3. Crie `docs/TROUBLESHOOTING.md`.

4. Atualize `README.md`.

5. Adicionar refer√™ncias em `README.md` para docs.

SA√çDA ESPERADA:
- `docs/DEPLOYMENT.md`
- `docs/CONTRIBUTING.md`
- `docs/TROUBLESHOOTING.md`
- `README.md` (finalizado)

CRIT√âRIOS DE ACEITE:
- [ ] Documenta√ß√£o clara e completa.
- [ ] Guias pr√°ticos.
- [ ] Troubleshooting √∫til.
- [ ] README atualizado.

N√ÉO FAZER:
- N√£o fazer documenta√ß√£o muito t√©cnica.
```

***

## Como Validar Localmente

Ap√≥s completar ETAPA 1-8, execute:

```bash
# 1. Type Check & Lint
npm run type-check
npm run lint

# 2. Testes
npm run test                    # Unit tests
npm run test:e2e               # E2E tests
npm run test:perf              # Performance tests
npm run test -- --coverage      # Coverage report

# 3. Build
npm run build

# 4. Performance Audit (local)
npm run test:lighthouse         # Lighthouse audit

# 5. Docker (opcional)
docker build -t bound:latest .
docker run -p 3000:3000 bound:latest

# 6. Deploy Local (Vercel/Netlify)
npm run preview                 # Preview production build locally
```

***

## Checklist Final - O que Deve Estar Pronto

### Code & Quality
- ‚úÖ TypeScript strict mode (zero errors)
- ‚úÖ ESLint sem warnings
- ‚úÖ Unit tests >85% coverage
- ‚úÖ E2E tests cobrindo fluxos cr√≠ticos (10+ testes)
- ‚úÖ Performance tests inclusos
- ‚úÖ No console errors/warnings em produ√ß√£o

### Features
- ‚úÖ Full CRUD: √°rea, conte√∫do, propriedade, link
- ‚úÖ Canvas editor: desenhar shapes, editar propriedades
- ‚úÖ Graph viewer: visualizar e navegar
- ‚úÖ Export/import: .bound files comprimidos
- ‚úÖ Merge strategies: Replace, Merge, Selective
- ‚úÖ Keyboard shortcuts: Ctrl+S, Ctrl+E, Escape, Del
- ‚úÖ Dark mode: 100% da UI

### UI/UX
- ‚úÖ Navigation completa (Home, Area, Content, Graph)
- ‚úÖ Navbar com bot√µes (Home, Graph, Export, Import, Settings)
- ‚úÖ Responsivo (mobile, tablet, desktop)
- ‚úÖ Progress bars durante export/import
- ‚úÖ Toasts para feedback
- ‚úÖ Error messages √∫teis
- ‚úÖ Loading indicators

### Deployment & Ops
- ‚úÖ CI/CD com GitHub Actions (test + build + deploy)
- ‚úÖ E2E tests rodam no CI
- ‚úÖ Coverage reports
- ‚úÖ Vercel/Netlify deployment automatizado
- ‚úÖ Docker image build√°vel
- ‚úÖ Performance targets atingidos
- ‚úÖ Error tracking (Sentry ou simples)

### Documentation
- ‚úÖ README completo
- ‚úÖ Guia de deployment
- ‚úÖ Guia de contributing
- ‚úÖ Troubleshooting
- ‚úÖ File format spec
- ‚úÖ API documentation (se houver)

### Performance
- ‚úÖ FCP <1.8s
- ‚úÖ Build size <200KB gzipped
- ‚úÖ Graph renderiza 100+ n√≥s sem lag
- ‚úÖ Canvas editor smooth (60 FPS)
- ‚úÖ Compress√£o .bound 70-90%

### Security
- ‚úÖ No hardcoded secrets
- ‚úÖ Sanitiza√ß√£o de inputs
- ‚úÖ CORS headers corretos
- ‚úÖ No XSS vulnerabilities
- ‚úÖ Environment variables configuradas