# üìÑ FASE 5: Export/Import & File Handling

## ESTRUTURA GERAL

A **Fase 5** refina e completa o sistema de export/import de arquivos `.bound`, implementando valida√ß√£o robusta, compress√£o gzip, merge inteligente, e feedback de usu√°rio profissional. Seu objetivo √© criar:

1. **BoundSerializer Avan√ßado** com compress√£o gzip, versionamento, e valida√ß√£o rigorosa
2. **Merge Strategy** que permite adicionar novas √°reas vs substituir estado completo
3. **Import Wizard** com preview de dados e confirma√ß√£o
4. **File Handling Utilities** para ler/escrever arquivos com seguran√ßa
5. **Error Recovery** com rollback em caso de falha
6. **User Feedback** com progress bars, toasts, e logs de debug

Ao final da Fase 5, voc√™ ter√° um **sistema de export/import profissional e robusto**, capaz de lidar com arquivos corrompidos, vers√µes antigas, e grandes volumes de dados.

***

## FASE 5: Export/Import & File Handling

### ETAPA 1: Instalar & Configurar Compress√£o (pako/gzip)

**Objetivo:**  
Instalar biblioteca de compress√£o gzip para reduzir tamanho de arquivos `.bound`.

**Arquivos principais a tocar:**
- `package.json`
- `src/constants/file.ts` (magic numbers, versioning)

**Prompt para IA:**

```text
Voc√™ √© um engenheiro backend/infra especializado em compress√£o e serializa√ß√£o.

TAREFA:
Instalar e configurar biblioteca de compress√£o gzip para arquivos .bound.

CONTEXTO IMPORTANTE:
- Arquivos .bound sem compress√£o podem ficar grandes (100+ MB com muitos shapes).
- Gzip reduz tamanho em ~80-90%.
- Usar `pako` (JavaScript port de zlib).
- Versionamento de arquivo para compatibilidade futura.

FUNCIONALIDADE DESEJADA:

1. **Instala√ß√£o:**
   - `npm install pako`
   - `npm install --save-dev @types/pako`

2. **Constantes de Versionamento:**
   ```typescript
   // src/constants/file.ts
   export const BOUND_FILE_VERSION = 1;
   export const BOUND_FILE_MAGIC = 'BOUND'; // Magic number para validar arquivo
   export const BOUND_FILE_EXTENSION = '.bound';
   
   export interface BoundFileHeader {
     magic: string; // 'BOUND'
     version: number; // 1, 2, etc.
     timestamp: number; // quando foi criado
     checksum?: string; // opcional para integridade
   }

   export const COMPRESSION_LEVEL = 9; // 1-9, 9 = m√°xima compress√£o
   ```

3. **Tipos de Erro:**
   ```typescript
   export enum FileErrorCode {
     INVALID_MAGIC = 'INVALID_MAGIC',
     INVALID_VERSION = 'INVALID_VERSION',
     CORRUPTED_DATA = 'CORRUPTED_DATA',
     DECOMPRESS_FAILED = 'DECOMPRESS_FAILED',
     INVALID_JSON = 'INVALID_JSON',
   }

   export class FileError extends Error {
     constructor(
       public code: FileErrorCode,
       message: string,
       public details?: Record<string, any>,
     ) {
       super(message);
       this.name = 'FileError';
     }
   }
   ```

INSTRU√á√ïES T√âCNICAS:

1. Execute:
   ```bash
   npm install pako
   npm install --save-dev @types/pako
   ```

2. Crie `src/constants/file.ts`:
   - Constantes de versionamento
   - Magic number
   - Enum de erros
   - FileError class

3. Type check:
   ```bash
   npm run type-check
   ```

SA√çDA ESPERADA:
- `pako` instalado.
- `src/constants/file.ts` com constantes e tipos.
- TypeScript sem erros.

CRIT√âRIOS DE ACEITE:
- [ ] `npm install` funciona.
- [ ] `npm run type-check` passa.
- [ ] `import pako from 'pako'` funciona.
- [ ] FileError class pode ser instantiada.

N√ÉO FAZER:
- N√£o usar bibliotecas alternativas (j√° escolhemos pako).
```

***

### ETAPA 2: Refatorar BoundSerializer com Compress√£o & Versionamento

**Objetivo:**  
Refatorar `BoundSerializer` para suportar compress√£o, versionamento, e valida√ß√£o robusta.

**Arquivos principais a tocar:**
- `src/utils/serialization/BoundSerializer.ts` (refatora√ß√£o)
- `src/utils/serialization/BoundSerializer.test.ts` (testes expandidos)
- `src/utils/serialization/BoundDecompressor.ts` (helper)

**Prompt para IA:**

```text
Voc√™ √© um engenheiro de software especializado em serializa√ß√£o, compress√£o e data integrity.

TAREFA:
Refatorar BoundSerializer para suportar compress√£o gzip, versionamento, valida√ß√£o, e migration de vers√µes antigas.

CONTEXTO IMPORTANTE:
- Backwards compatibility: poder ler arquivos de vers√µes antigas.
- Forward compatibility: graceful handling de vers√µes futuras (warn).
- Integridade: validar magic number, checksum, JSON validity.
- Performance: compress√£o n√£o deve ser bottleneck (async?).

FUNCIONALIDADE DESEJADA:

1. **BoundSerializer Refatorado:**
   ```typescript
   export class BoundSerializer {
     /**
      * Encode AppState em arquivo .bound comprimido
      * Retorna Uint8Array (buffer comprimido)
      */
     static async encode(state: AppState): Promise<Uint8Array> {
       // 1. Serializar state em JSON
       const json = JSON.stringify(state);
       
       // 2. Criar header
       const header: BoundFileHeader = {
         magic: BOUND_FILE_MAGIC,
         version: BOUND_FILE_VERSION,
         timestamp: Date.now(),
       };
       
       // 3. Combinar header + json (format: header.magic|header.version|header.timestamp|json)
       const headerStr = `${header.magic}|${header.version}|${header.timestamp}|`;
       const combined = headerStr + json;
       
       // 4. Comprimir com pako
       const compressed = pako.gzip(combined);
       
       return new Uint8Array(compressed);
     }

     /**
      * Decode arquivo .bound comprimido em AppState
      * L√™ Uint8Array, descomprime, valida, retorna state
      */
     static async decode(buffer: Uint8Array): Promise<AppState> {
       try {
         // 1. Descomprimir
         const decompressed = pako.ungzip(buffer, { to: 'string' });
         
         // 2. Parse header
         const [magic, versionStr, timestampStr, ...jsonParts] = decompressed.split('|');
         const version = parseInt(versionStr, 10);
         const timestamp = parseInt(timestampStr, 10);
         const json = jsonParts.join('|'); // rejoin in case json contains '|'
         
         // 3. Validar
         if (magic !== BOUND_FILE_MAGIC) {
           throw new FileError(
             FileErrorCode.INVALID_MAGIC,
             `Invalid file format. Expected magic "${BOUND_FILE_MAGIC}", got "${magic}"`,
           );
         }
         
         if (version !== BOUND_FILE_VERSION) {
           if (version > BOUND_FILE_VERSION) {
             console.warn(`File version ${version} newer than app version ${BOUND_FILE_VERSION}`);
           }
           // Migration logic for older versions (future)
         }
         
         if (isNaN(timestamp)) {
           throw new FileError(FileErrorCode.CORRUPTED_DATA, 'Invalid timestamp in file header');
         }
         
         // 4. Parse JSON
         let state: AppState;
         try {
           state = JSON.parse(json);
         } catch (err) {
           throw new FileError(
             FileErrorCode.INVALID_JSON,
             'Failed to parse JSON data',
             { originalError: (err as Error).message },
           );
         }
         
         // 5. Validar state (basic)
         if (!isAppState(state)) {
           throw new FileError(
             FileErrorCode.INVALID_JSON,
             'Decoded data does not match AppState schema',
           );
         }
         
         return state;
       } catch (err) {
         if (err instanceof FileError) throw err;
         throw new FileError(
           FileErrorCode.DECOMPRESS_FAILED,
           `Failed to decompress file: ${(err as Error).message}`,
           { originalError: err },
         );
       }
     }

     /**
      * Validate arquivo .bound sem decodificar completamente
      * √ötil para preview antes de import
      */
     static async validate(buffer: Uint8Array): Promise<{
       valid: boolean;
       version: number;
       timestamp: number;
       size: number;
       error?: FileError;
     }> {
       try {
         const decompressed = pako.ungzip(buffer, { to: 'string' });
         const [magic, versionStr, timestampStr] = decompressed.split('|');
         
         const version = parseInt(versionStr, 10);
         const timestamp = parseInt(timestampStr, 10);
         
         if (magic !== BOUND_FILE_MAGIC) {
           throw new FileError(
             FileErrorCode.INVALID_MAGIC,
             'Invalid file magic number',
           );
         }
         
         return {
           valid: true,
           version,
           timestamp,
           size: buffer.length,
         };
       } catch (err) {
         return {
           valid: false,
           version: 0,
           timestamp: 0,
           size: buffer.length,
           error: err instanceof FileError 
             ? err 
             : new FileError(FileErrorCode.DECOMPRESS_FAILED, (err as Error).message),
         };
       }
     }

     /**
      * Helper: file.size em formato leg√≠vel (1.2 MB, etc.)
      */
     static formatFileSize(bytes: number): string {
       const units = ['B', 'KB', 'MB', 'GB'];
       let size = bytes;
       let unitIndex = 0;
       
       while (size > 1024 && unitIndex < units.length - 1) {
         size /= 1024;
         unitIndex++;
       }
       
       return `${size.toFixed(2)} ${units[unitIndex]}`;
     }
   }
   ```

2. **Type Guard para AppState:**
   ```typescript
   // src/utils/serialization/isAppState.ts
   export function isAppState(obj: unknown): obj is AppState {
     if (typeof obj !== 'object' || obj === null) return false;
     const o = obj as Record<string, unknown>;
     
     return (
       Array.isArray(o.areas) &&
       Array.isArray(o.contents) &&
       Array.isArray(o.links) &&
       Array.isArray(o.properties)
     );
   }
   ```

3. **Testes Expandidos:**
   ```typescript
   describe('BoundSerializer', () => {
     it('should encode and decode state', async () => {
       const state = getDefaultState();
       const encoded = await BoundSerializer.encode(state);
       const decoded = await BoundSerializer.decode(encoded);
       
       expect(decoded.areas).toEqual(state.areas);
       expect(decoded.contents).toEqual(state.contents);
     });

     it('should compress to smaller size', async () => {
       const state = getDefaultState();
       // Add many shapes to make it large
       for (let i = 0; i < 100; i++) {
         const area = AreaManager.createArea(`Area ${i}`, state);
         state.areas.push(area);
       }
       
       const json = JSON.stringify(state);
       const encoded = await BoundSerializer.encode(state);
       
       const ratio = (encoded.length / json.length) * 100;
       console.log(`Compression ratio: ${ratio.toFixed(2)}%`);
       expect(encoded.length).toBeLessThan(json.length);
     });

     it('should validate file without full decode', async () => {
       const state = getDefaultState();
       const encoded = await BoundSerializer.encode(state);
       
       const validation = await BoundSerializer.validate(encoded);
       expect(validation.valid).toBe(true);
       expect(validation.version).toBe(BOUND_FILE_VERSION);
     });

     it('should reject invalid magic number', async () => {
       const badBuffer = new Uint8Array([0xFF, 0xFE, 0xFD]);
       
       const validation = await BoundSerializer.validate(badBuffer);
       expect(validation.valid).toBe(false);
       expect(validation.error?.code).toBe(FileErrorCode.INVALID_MAGIC);
     });

     it('should reject corrupted json', async () => {
       const state = getDefaultState();
       const encoded = await BoundSerializer.encode(state);
       
       // Corromper 10 bytes aleatoriamente
       const corrupted = new Uint8Array(encoded);
       for (let i = 0; i < 10; i++) {
         corrupted[Math.random() * corrupted.length | 0] ^= 0xFF;
       }
       
       await expect(BoundSerializer.decode(corrupted)).rejects.toThrow();
     });
   });
   ```

INSTRU√á√ïES T√âCNICAS:

1. Refatore `src/utils/serialization/BoundSerializer.ts`:
   - Adicionar compress/decompress logic
   - Valida√ß√£o rigorosa
   - Error handling

2. Crie `src/utils/serialization/isAppState.ts`.

3. Expandir testes.

4. Coverage >85%.

SA√çDA ESPERADA:
- `src/utils/serialization/BoundSerializer.ts` (refatorado)
- `src/utils/serialization/isAppState.ts`
- `src/utils/serialization/BoundSerializer.test.ts` (expandido)

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test` passa.
- [ ] Compress√£o funciona (file size reduz 70%+).
- [ ] Valida√ß√£o rejeita arquivos inv√°lidos.
- [ ] Coverage >85%.
- [ ] TypeScript strict.

N√ÉO FAZER:
- N√£o fazer async i/o (apenas processamento em mem√≥ria).
```

***

### ETAPA 3: Implementar Merge Strategy & Import Wizard

**Objetivo:**  
Criar estrat√©gias de merge (replace, merge, selective merge) e wizard de import com preview.

**Arquivos principais a tocar:**
- `src/managers/ImportManager.ts`
- `src/managers/ImportManager.test.ts`
- `src/components/ImportWizard.tsx`

**Prompt para IA:**

```text
Voc√™ √© um engenheiro de software especializado em data migration e merge strategies.

TAREFA:
Implementar ImportManager com estrat√©gias de merge, e componente ImportWizard com preview de dados.

CONTEXTO IMPORTANTE:
- Merge strategies:
  1. REPLACE: substituir estado completo (destructivo)
  2. MERGE: adicionar √°reas novas, manter existentes (non-destructivo)
  3. SELECTIVE: usu√°rio escolhe quais √°reas importar
- ImportWizard: modal com steps (1: valida√ß√£o, 2: preview, 3: estrat√©gia, 4: confirma√ß√£o)
- Rollback: em caso de erro, restaurar estado anterior

FUNCIONALIDADE DESEJADA:

1. **ImportManager:**
   ```typescript
   export enum MergeStrategy {
     REPLACE = 'replace',     // substituir tudo
     MERGE = 'merge',         // adicionar novas √°reas (se id duplicado, skip)
     SELECTIVE = 'selective', // usu√°rio escolhe quais √°reas
   }

   export interface ImportPreview {
     source: AppState;
     strategy: MergeStrategy;
     areasToAdd: Area[];     // novas √°reas
     areasToSkip: Area[];    // √°reas duplicadas (se MERGE)
     conflictCount: number;  // quantos conflitos
   }

   export class ImportManager {
     /**
      * Analisar arquivo importado e criar preview
      */
     static async preview(
       importedState: AppState,
       currentState: AppState,
       strategy: MergeStrategy,
     ): Promise<ImportPreview> {
       const areasToAdd: Area[] = [];
       const areasToSkip: Area[] = [];
       
       for (const importedArea of importedState.areas) {
         const existing = currentState.areas.find((a) => a.id === importedArea.id);
         
         if (existing) {
           if (strategy === MergeStrategy.MERGE) {
             areasToSkip.push(importedArea);
           } else if (strategy === MergeStrategy.REPLACE) {
             // tudo vai ser substitu√≠do anyway
           }
         } else {
           areasToAdd.push(importedArea);
         }
       }
       
       return {
         source: importedState,
         strategy,
         areasToAdd,
         areasToSkip,
         conflictCount: areasToSkip.length,
       };
     }

     /**
      * Executar merge de acordo com estrat√©gia
      */
     static merge(
       currentState: AppState,
       importedState: AppState,
       strategy: MergeStrategy,
       selectedAreaIds?: string[], // para SELECTIVE
     ): AppState {
       if (strategy === MergeStrategy.REPLACE) {
         return importedState;
       }
       
       if (strategy === MergeStrategy.MERGE) {
         // Adicionar √°reas que n√£o existem
         const newAreas = importedState.areas.filter(
           (a) => !currentState.areas.find((ca) => ca.id === a.id),
         );
         
         // Adicionar conte√∫dos, links das √°reas novas
         const newAreaIds = new Set(newAreas.map((a) => a.id));
         const newContents = importedState.contents.filter(
           (c) => newAreaIds.has(c.areaId),
         );
         const newLinks = importedState.links.filter(
           (l) => {
             const fromArea = importedState.contents.find((c) => c.id === l.fromContentId)?.areaId;
             const toArea = importedState.contents.find((c) => c.id === l.toContentId)?.areaId;
             return fromArea && toArea && newAreaIds.has(fromArea) && newAreaIds.has(toArea);
           },
         );
         
         // Adicionar properties que referem √°reas novas
         const newProperties = importedState.properties.filter(
           (p) => newAreaIds.has(p.areaId),
         );
         
         return {
           ...currentState,
           areas: [...currentState.areas, ...newAreas],
           contents: [...currentState.contents, ...newContents],
           links: [...currentState.links, ...newLinks],
           properties: [...currentState.properties, ...newProperties],
         };
       }
       
       if (strategy === MergeStrategy.SELECTIVE && selectedAreaIds) {
         // Similar a MERGE, mas apenas com √°reas selecionadas
         const selectedSet = new Set(selectedAreaIds);
         const newAreas = importedState.areas.filter(
           (a) => selectedSet.has(a.id) && !currentState.areas.find((ca) => ca.id === a.id),
         );
         // ... (similar logic)
       }
       
       return currentState;
     }

     /**
      * Rollback: restaurar estado anterior em caso de erro
      */
     static rollback(currentState: AppState, previousState: AppState): AppState {
       return previousState;
     }
   }
   ```

2. **ImportWizard Component:**
   ```typescript
   export function ImportWizard({
     file: File,
     onConfirm: (result: ImportResult) => void,
     onCancel: () => void,
   }) {
     const [step, setStep] = useState(1); // 1-4
     const [importedState, setImportedState] = useState<AppState | null>(null);
     const [strategy, setStrategy] = useState<MergeStrategy>(MergeStrategy.MERGE);
     const [preview, setPreview] = useState<ImportPreview | null>(null);
     const [selectedAreaIds, setSelectedAreaIds] = useState<string[]>([]);
     const [isLoading, setIsLoading] = useState(false);
     const [error, setError] = useState<string | null>(null);
     const { state: currentState } = useAppStore(useShallow((s) => ({ state: s.state })));

     const handleValidate = async () => {
       setIsLoading(true);
       try {
         const buffer = await file.arrayBuffer();
         const decoded = await BoundSerializer.decode(new Uint8Array(buffer));
         setImportedState(decoded);
         setStep(2);
       } catch (err) {
         setError((err as Error).message);
       } finally {
         setIsLoading(false);
       }
     };

     const handleStrategySelect = async (s: MergeStrategy) => {
       setStrategy(s);
       const p = await ImportManager.preview(importedState!, currentState, s);
       setPreview(p);
       setStep(3);
     };

     const handleConfirm = async () => {
       setIsLoading(true);
       try {
         const merged = ImportManager.merge(
           currentState,
           importedState!,
           strategy,
           strategy === MergeStrategy.SELECTIVE ? selectedAreaIds : undefined,
         );
         onConfirm({ success: true, mergedState: merged, itemsImported: preview?.areasToAdd.length || 0 });
       } catch (err) {
         setError((err as Error).message);
       } finally {
         setIsLoading(false);
       }
     };

     return (
       <div className="import-wizard">
         {step === 1 && (
           <div>
             <h2>Validating File...</h2>
             {isLoading ? <Spinner /> : null}
             {error ? <Alert type="error">{error}</Alert> : null}
             <button onClick={handleValidate} disabled={isLoading}>
               Next
             </button>
             <button onClick={onCancel}>Cancel</button>
           </div>
         )}

         {step === 2 && (
           <div>
             <h2>Choose Import Strategy</h2>
             <div>
               <label>
                 <input
                   type="radio"
                   value="replace"
                   checked={strategy === MergeStrategy.REPLACE}
                   onChange={(e) => handleStrategySelect(e.target.value as MergeStrategy)}
                 />
                 Replace All (destructive)
               </label>
               <label>
                 <input
                   type="radio"
                   value="merge"
                   checked={strategy === MergeStrategy.MERGE}
                   onChange={(e) => handleStrategySelect(e.target.value as MergeStrategy)}
                 />
                 Merge (add new areas only)
               </label>
               <label>
                 <input
                   type="radio"
                   value="selective"
                   checked={strategy === MergeStrategy.SELECTIVE}
                   onChange={(e) => handleStrategySelect(e.target.value as MergeStrategy)}
                 />
                 Selective (choose areas)
               </label>
             </div>
           </div>
         )}

         {step === 3 && preview && (
           <div>
             <h2>Import Preview</h2>
             <p>Areas to add: {preview.areasToAdd.length}</p>
             <p>Conflicts: {preview.conflictCount}</p>
             {preview.conflictCount > 0 && (
               <Alert type="warning">
                 {preview.conflictCount} areas will be skipped due to ID conflicts.
               </Alert>
             )}
             <button onClick={handleConfirm} disabled={isLoading}>
               Confirm Import
             </button>
             <button onClick={onCancel}>Cancel</button>
           </div>
         )}

         {step === 4 && (
           <div>
             <h2>Import Complete</h2>
             <p>Successfully imported data.</p>
             <button onClick={onCancel}>Close</button>
           </div>
         )}
       </div>
     );
   }
   ```

INSTRU√á√ïES T√âCNICAS:

1. Crie `src/managers/ImportManager.ts`.

2. Crie `src/components/ImportWizard.tsx`.

3. Testes >85% coverage.

SA√çDA ESPERADA:
- `src/managers/ImportManager.ts`
- `src/components/ImportWizard.tsx`
- `src/managers/ImportManager.test.ts`

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test` passa.
- [ ] Merge strategies funcionam corretamente.
- [ ] Preview mostra informa√ß√µes corretas.
- [ ] ImportWizard renderiza e funciona.
- [ ] Coverage >85%.

N√ÉO FAZER:
- N√£o fazer UI muito complexa (simples √© ok para Fase 5).
```

***

### ETAPA 4: Integrar ImportButton com ImportWizard

**Objetivo:**  
Refatorar `ImportButton` para usar `ImportWizard` em vez de simples confirm().

**Arquivos principais a tocar:**
- `src/components/ImportButton.tsx` (refatora√ß√£o)

**Prompt para IA:**

```text
Voc√™ √© um expert em UX e React components.

TAREFA:
Refatorar ImportButton para integrar ImportWizard, mostrando wizard modal em vez de simples confirm().

CONTEXTO IMPORTANTE:
- ImportButton continua no navbar.
- Click em ImportButton abre ImportWizard modal.
- ImportWizard conduz usu√°rio atrav√©s dos steps.
- Ao finalizar, atualiza store via useAppStore.
- Toast de sucesso/erro.

FUNCIONALIDADE DESEJADA:

1. **ImportButton Refatorado:**
   ```typescript
   export function ImportButton() {
     const fileInputRef = useRef<HTMLInputElement>(null);
     const [showWizard, setShowWizard] = useState(false);
     const [selectedFile, setSelectedFile] = useState<File | null>(null);
     
     const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
       const file = e.target.files?.;
       if (file) {
         setSelectedFile(file);
         setShowWizard(true);
       }
     };

     const handleWizardConfirm = (result: ImportResult) => {
       if (result.success) {
         useAppStore.getState().setState(result.mergedState);
         showToast('success', `Imported ${result.itemsImported} items`);
       } else {
         showToast('error', result.error || 'Import failed');
       }
       setShowWizard(false);
       setSelectedFile(null);
     };

     const handleWizardCancel = () => {
       setShowWizard(false);
       setSelectedFile(null);
     };

     return (
       <>
         <button onClick={() => fileInputRef.current?.click()}>Import</button>
         <input
           ref={fileInputRef}
           type="file"
           accept=".bound"
           onChange={handleFileSelect}
           style={{ display: 'none' }}
         />
         
         {showWizard && selectedFile && (
           <Modal onClose={handleWizardCancel}>
             <ImportWizard
               file={selectedFile}
               onConfirm={handleWizardConfirm}
               onCancel={handleWizardCancel}
             />
           </Modal>
         )}
       </>
     );
   }
   ```

INSTRU√á√ïES T√âCNICAS:

1. Refatore `src/components/ImportButton.tsx`.

2. Integre ImportWizard.

3. Teste manualmente:
   - Click Import
   - Selecionar arquivo .bound
   - Wizard deve abrir
   - Seguir steps
   - Importar deve atualizar app state

SA√çDA ESPERADA:
- `src/components/ImportButton.tsx` (refatorado)

CRIT√âRIOS DE ACEITE:
- [ ] ImportButton abre wizard.
- [ ] Wizard funciona end-to-end.
- [ ] State atualizado ap√≥s import.
- [ ] Toasts mostram feedback.

N√ÉO FAZER:
- N√£o fazer UI muito complexa.
```

***

### ETAPA 5: Implementar File Utilities & Error Recovery

**Objetivo:**  
Criar utilit√°rios para lidar com arquivo, valida√ß√£o, error handling, e recovery.

**Arquivos principais a tocar:**
- `src/utils/file/index.ts`
- `src/utils/file/errorHandling.ts`

**Prompt para IA:**

```text
Voc√™ √© um engenheiro de sistemas especializado em file I/O e error handling.

TAREFA:
Implementar utilit√°rios para file handling, valida√ß√£o, e error recovery.

CONTEXTO IMPORTANTE:
- Download de arquivo: Blob ‚Üí URL ‚Üí download
- Upload de arquivo: input file ‚Üí validate ‚Üí read
- Error recovery: em caso de erro, restaurar estado anterior
- Logging: debug logs para troubleshooting

FUNCIONALIDADE DESEJADA:

1. **File Utilities:**
   ```typescript
   // src/utils/file/index.ts
   export async function downloadFile(
     data: Uint8Array,
     filename: string,
   ): Promise<void> {
     const blob = new Blob([data], { type: 'application/octet-stream' });
     const url = URL.createObjectURL(blob);
     const a = document.createElement('a');
     a.href = url;
     a.download = filename;
     document.body.appendChild(a);
     a.click();
     document.body.removeChild(a);
     URL.revokeObjectURL(url);
   }

   export async function readFile(file: File): Promise<Uint8Array> {
     return new Promise((resolve, reject) => {
       const reader = new FileReader();
       reader.onload = () => {
         resolve(new Uint8Array(reader.result as ArrayBuffer));
       };
       reader.onerror = () => {
         reject(new Error('Failed to read file'));
       };
       reader.readAsArrayBuffer(file);
     });
   }

   export function getFileInfo(file: File): FileInfo {
     return {
       name: file.name,
       size: file.size,
       type: file.type,
       lastModified: new Date(file.lastModified),
     };
   }

   export interface FileInfo {
     name: string;
     size: number;
     type: string;
     lastModified: Date;
   }
   ```

2. **Error Handling:**
   ```typescript
   // src/utils/file/errorHandling.ts
   export function handleFileError(error: unknown): string {
     if (error instanceof FileError) {
       const messages: Record<FileErrorCode, string> = {
         [FileErrorCode.INVALID_MAGIC]: 'Invalid file format. This is not a valid BOUND file.',
         [FileErrorCode.INVALID_VERSION]: 'File version not supported.',
         [FileErrorCode.CORRUPTED_DATA]: 'File is corrupted. Try another file.',
         [FileErrorCode.DECOMPRESS_FAILED]: 'Failed to decompress file.',
         [FileErrorCode.INVALID_JSON]: 'File contains invalid data.',
       };
       return messages[error.code] || error.message;
     }
     
     if (error instanceof Error) {
       return error.message;
     }
     
     return 'An unknown error occurred.';
   }

   export function logError(context: string, error: unknown): void {
     console.error(`[${context}]`, error);
     // Opcionalmente, enviar para analytics/sentry (future)
   }
   ```

3. **Recovery Utility:**
   ```typescript
   // src/utils/storage/recovery.ts
   export class RecoveryManager {
     static readonly BACKUP_KEY = 'bound_backup_state';

     static createBackup(state: AppState): void {
       try {
         const json = JSON.stringify(state);
         localStorage.setItem(this.BACKUP_KEY, json);
       } catch (err) {
         console.error('Failed to create backup:', err);
       }
     }

     static restoreBackup(): AppState | null {
       try {
         const json = localStorage.getItem(this.BACKUP_KEY);
         if (!json) return null;
         return JSON.parse(json);
       } catch (err) {
         console.error('Failed to restore backup:', err);
         return null;
       }
     }

     static clearBackup(): void {
       localStorage.removeItem(this.BACKUP_KEY);
     }
   }
   ```

4. **Testes:**
   ```typescript
   describe('File Utils', () => {
     it('should download file', async () => {
       const data = new Uint8Array();
       // Mock document methods
       const mockClick = jest.fn();
       document.createElement = jest.fn((tag) => {
         if (tag === 'a') {
           return { click: mockClick, href: '', download: '' } as any;
         }
         return document.createElement(tag);
       });
       
       await downloadFile(data, 'test.bound');
       expect(mockClick).toHaveBeenCalled();
     });

     it('should handle file errors gracefully', () => {
       const error = new FileError(
         FileErrorCode.INVALID_MAGIC,
         'Bad magic',
       );
       const message = handleFileError(error);
       expect(message).toContain('Invalid file format');
     });

     it('should backup and restore state', () => {
       const state = getDefaultState();
       RecoveryManager.createBackup(state);
       
       const restored = RecoveryManager.restoreBackup();
       expect(restored).toEqual(state);
     });
   });
   ```

INSTRU√á√ïES T√âCNICAS:

1. Crie `src/utils/file/index.ts`.

2. Crie `src/utils/file/errorHandling.ts`.

3. Crie `src/utils/storage/recovery.ts`.

4. Testes >85% coverage.

SA√çDA ESPERADA:
- `src/utils/file/index.ts`
- `src/utils/file/errorHandling.ts`
- `src/utils/storage/recovery.ts`
- Testes

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test` passa.
- [ ] File download funciona.
- [ ] File read funciona.
- [ ] Errors tratados gracefully.
- [ ] Recovery funciona.
- [ ] Coverage >85%.

N√ÉO FAZER:
- N√£o fazer upload para servidor (offline app).
```

***

### ETAPA 6: Adicionar Progress Bars & User Feedback

**Objetivo:**  
Implementar progress indicators e user feedback robustos durante export/import.

**Arquivos principais a tocar:**
- `src/components/ExportButton.tsx` (refinado)
- `src/components/ImportButton.tsx` (refinado)
- `src/components/ProgressBar.tsx` (novo)
- `src/hooks/useToast.ts` (refinado)

**Prompt para IA:**

```text
Voc√™ √© um expert em UX e feedback de usu√°rio.

TAREFA:
Adicionar progress bars, loading indicators, e toasts de feedback durante export/import.

CONTEXTO IMPORTANTE:
- Export: progress bar com percentual de compress√£o
- Import: progress bar durante decompress + valida√ß√£o + merge
- Toasts: sucesso/erro com mensagens descritivas
- Cancelamento: permitir cancel durante opera√ß√µes longas

FUNCIONALIDADE DESEJADA:

1. **ProgressBar Component:**
   ```typescript
   export function ProgressBar({
     progress: number; // 0-100
     status?: string;  // "Compressing...", etc
     cancellable?: boolean;
     onCancel?: () => void;
   }) {
     return (
       <div className="progress-container">
         <div className="progress-bar">
           <div className="progress-fill" style={{ width: `${progress}%` }} />
         </div>
         {status && <p className="progress-status">{status}</p>}
         {cancellable && (
           <button onClick={onCancel} className="progress-cancel">
             Cancel
           </button>
         )}
       </div>
     );
   }
   ```

2. **ExportButton Refinado:**
   ```typescript
   export function ExportButton() {
     const { state } = useAppStore(useShallow((s) => ({ state: s.state })));
     const { toast } = useToast();
     const [isExporting, setIsExporting] = useState(false);
     const [progress, setProgress] = useState(0);

     const handleExport = async () => {
       setIsExporting(true);
       setProgress(0);
       
       try {
         setProgress(10);
         const encoded = await BoundSerializer.encode(state);
         setProgress(80);
         
         const filename = `bound-${new Date().toISOString().slice(0, 10)}.bound`;
         await downloadFile(encoded, filename);
         setProgress(100);
         
         toast.success(`Exported ${BoundSerializer.formatFileSize(encoded.length)}`);
       } catch (err) {
         toast.error(`Export failed: ${handleFileError(err)}`);
         logError('ExportButton', err);
       } finally {
         setIsExporting(false);
         setProgress(0);
       }
     };

     return (
       <div>
         <button onClick={handleExport} disabled={isExporting}>
           {isExporting ? 'Exporting...' : 'Export'}
         </button>
         {isExporting && <ProgressBar progress={progress} status="Compressing..." />}
       </div>
     );
   }
   ```

3. **ImportButton Refinado:**
   - Similar, com progress durante decompress, valida√ß√£o, merge

4. **Toast Hook:**
   ```typescript
   // src/hooks/useToast.ts
   export interface Toast {
     id: string;
     type: 'success' | 'error' | 'warning' | 'info';
     message: string;
     duration?: number; // ms, default 4000
   }

   export function useToast() {
     const [toasts, setToasts] = useState<Toast[]>([]);

     const addToast = (type: Toast['type'], message: string, duration = 4000) => {
       const id = generateId();
       const toast: Toast = { id, type, message, duration };
       setToasts((prev) => [...prev, toast]);
       
       if (duration > 0) {
         setTimeout(() => {
           setToasts((prev) => prev.filter((t) => t.id !== id));
         }, duration);
       }
     };

     const success = (message: string) => addToast('success', message);
     const error = (message: string) => addToast('error', message);
     const warning = (message: string) => addToast('warning', message);
     const info = (message: string) => addToast('info', message);

     return { toasts, success, error, warning, info, addToast };
   }
   ```

5. **ToastContainer Component:**
   ```typescript
   export function ToastContainer() {
     const { toasts } = useToast();

     return (
       <div className="toast-container">
         {toasts.map((toast) => (
           <Toast key={toast.id} {...toast} />
         ))}
       </div>
     );
   }
   ```

INSTRU√á√ïES T√âCNICAS:

1. Crie `src/components/ProgressBar.tsx`.

2. Crie `src/components/ToastContainer.tsx`.

3. Crie `src/hooks/useToast.ts` (se ainda n√£o existe, refine).

4. Refatore export/import buttons.

5. Adicione ToastContainer no App root.

SA√çDA ESPERADA:
- `src/components/ProgressBar.tsx`
- `src/components/ToastContainer.tsx`
- Buttons refinados com progress/toasts
- Integra√ß√£o no App

CRIT√âRIOS DE ACEITE:
- [ ] Progress bar aparece durante export/import.
- [ ] Toasts mostram feedback de sucesso/erro.
- [ ] UX √© clara e responsiva.
- [ ] Cancel funciona (se implementado).

N√ÉO FAZER:
- N√£o fazer anima√ß√µes complexas.
```

***

### ETAPA 7: Testes & Valida√ß√£o Final

**Objetivo:**  
Suite completa de testes para export/import, merge, error handling, file I/O.

**Arquivos principais a tocar:**
- `tests/integration/export-import.integration.test.ts`
- `tests/e2e/export-import.e2e.test.ts` (opcional, Vitest)

**Prompt para IA:**

```text
Voc√™ √© um expert em testes de software.

TAREFA:
Implementar suite de testes abrangentes para export/import (Fase 5).

CONTEXTO IMPORTANTE:
- Testes unit√°rios: serializer, merger, file utils.
- Testes de integra√ß√£o: export ‚Üí import ‚Üí verify estado.
- Testes de edge cases: arquivos corrompidos, vers√µes antigas, merge conflicts.
- Coverage >85%.

FUNCIONALIDADE DESEJADA:

1. **Integration Tests:**
   ```typescript
   describe('Export/Import Integration', () => {
     it('should export and import state without loss', async () => {
       const original = getDefaultState();
       // Add data
       const area = AreaManager.createArea('Test', original);
       original.areas.push(area);
       
       // Export
       const encoded = await BoundSerializer.encode(original);
       
       // Import
       const imported = await BoundSerializer.decode(encoded);
       
       // Verify
       expect(imported.areas).toEqual(original.areas);
     });

     it('should merge states correctly', async () => {
       const state1 = getDefaultState();
       const area1 = AreaManager.createArea('Area 1', state1);
       state1.areas.push(area1);
       
       const state2 = getDefaultState();
       const area2 = AreaManager.createArea('Area 2', state2);
       state2.areas.push(area2);
       
       const merged = ImportManager.merge(state1, state2, MergeStrategy.MERGE);
       expect(merged.areas).toHaveLength(2);
     });

     it('should reject corrupted files', async () => {
       const corrupted = new Uint8Array([0xFF, 0xFE, 0xFD]);
       await expect(BoundSerializer.decode(corrupted)).rejects.toThrow();
     });

     it('should compress significantly', async () => {
       const state = getDefaultState();
       for (let i = 0; i < 50; i++) {
         const area = AreaManager.createArea(`Area ${i}`, state);
         state.areas.push(area);
       }
       
       const json = JSON.stringify(state);
       const encoded = await BoundSerializer.encode(state);
       
       const ratio = (encoded.length / json.length) * 100;
       expect(ratio).toBeLessThan(50); // Pelo menos 50% de compress√£o
     });
   });
   ```

2. **Edge Case Tests:**
   - Arquivo vazio
   - Arquivo muito grande
   - Vers√£o futura
   - Caracteres especiais
   - Unicode em titles

3. **Coverage Report.**

INSTRU√á√ïES T√âCNICAS:

1. Crie `tests/integration/export-import.integration.test.ts`.

2. Coverage report:
   ```bash
   npm run test -- --coverage
   ```

3. Alvo: >85% coverage.

SA√çDA ESPERADA:
- `tests/integration/export-import.integration.test.ts`
- Coverage report
- Todos os testes passando

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test` passa.
- [ ] Coverage >85%.
- [ ] Edge cases tratados.

N√ÉO FAZER:
- N√£o fazer E2E complexo (Fase 6).
```

***

### ETAPA 8: Documenta√ß√£o & Valida√ß√£o Final

**Objetivo:**  
Documentar sistema de export/import, formato .bound, e guia de troubleshooting.

**Arquivos principais a tocar:**
- `docs/EXPORT_IMPORT.md` (novo)
- `docs/FILE_FORMAT.md` (novo)

**Prompt para IA:**

```text
Voc√™ √© um technical writer especializado em documenta√ß√£o de software.

TAREFA:
Documentar sistema de export/import, formato .bound file, e guia de troubleshooting.

CONTEXTO IMPORTANTE:
- Documenta√ß√£o deve ser clara e execut√°vel.
- Incluir exemplos pr√°ticos.
- Troubleshooting common errors.
- File format spec para refer√™ncia de developers.

FUNCIONALIDADE DESEJADA:

1. **docs/EXPORT_IMPORT.md:**
   ```markdown
   # Export & Import Guide

   ## Overview
   BOUND uses .bound files to export and import application state. Files are compressed with gzip for efficiency.

   ## Export
   1. Click "Export" button in navbar
   2. File will be downloaded as `bound-YYYY-MM-DD.bound`
   3. Progress bar shows compression status

   ## Import
   1. Click "Import" button in navbar
   2. Select a .bound file
   3. ImportWizard will guide you through merge options:
      - **Replace**: Replaces entire state (destructive)
      - **Merge**: Adds new areas to existing state
      - **Selective**: Choose which areas to import

   ## Merge Strategies

   ### Replace
   Replaces all current data with imported file. Useful for complete backup restoration.

   ### Merge
   Adds imported areas to existing areas. If area ID already exists, it's skipped.

   ### Selective
   User chooses which areas to import. Useful for selective data integration.

   ## Troubleshooting

   ### "Invalid file format"
   - File is corrupted or not a .bound file
   - Try exporting again from another device
   - Check file extension

   ### "Decompression failed"
   - File may be partially downloaded
   - Try downloading again

   ### Import seems slow
   - Large files with 1000+ items may take a few seconds
   - Browser tab may appear frozen briefly; this is normal

   ### Merge conflicts
   - Areas with duplicate IDs will be shown in preview
   - Choose "Replace" to override, or "Merge" to skip duplicates
   ```

2. **docs/FILE_FORMAT.md:**
   ```markdown
   # BOUND File Format Specification

   ## Overview
   .bound files are gzip-compressed JSON archives containing application state.

   ## File Structure
   ```
   [GZIP COMPRESSED DATA]
   ‚îú‚îÄ‚îÄ Magic Number: "BOUND"
   ‚îú‚îÄ‚îÄ Version: 1
   ‚îú‚îÄ‚îÄ Timestamp: Unix timestamp
   ‚îî‚îÄ‚îÄ JSON: AppState serialized
   ```

   ## Format Details

   ### Header (uncompressed after gzip)
   ```
   BOUND|1|1707638400000|{...JSON...}
   ```

   - Magic: "BOUND" (5 bytes)
   - Pipe delimiter: "|" (1 byte)
   - Version: "1" (1 byte)
   - Pipe delimiter: "|" (1 byte)
   - Timestamp: Unix milliseconds (13 bytes typical)
   - Pipe delimiter: "|" (1 byte)
   - JSON: Serialized AppState

   ### AppState Schema
   ```typescript
   {
     areas: Area[],
     contents: Content[],
     links: Link[],
     properties: Property[]
   }
   ```

   ## Compression
   - Algorithm: gzip (RFC 1952)
   - Compression level: 9 (maximum)
   - Typical ratio: 10-20% of original size

   ## Versioning
   - Current version: 1
   - Future versions will include migration logic
   - Old versions: gracefully upgraded or rejected with clear error

   ## Validation
   - Magic number must be "BOUND"
   - JSON must be valid and match AppState schema
   - Checksum optional (future feature)

   ## Error Codes
   - INVALID_MAGIC: Magic number doesn't match
   - INVALID_VERSION: Version not supported
   - DECOMPRESS_FAILED: Gzip decompression error
   - INVALID_JSON: JSON parse error
   - CORRUPTED_DATA: Data integrity check failed
   ```

INSTRU√á√ïES T√âCNICAS:

1. Crie `docs/EXPORT_IMPORT.md`.

2. Crie `docs/FILE_FORMAT.md`.

3. Inclua em `README.md` refer√™ncias √† documenta√ß√£o.

SA√çDA ESPERADA:
- `docs/EXPORT_IMPORT.md`
- `docs/FILE_FORMAT.md`
- README.md atualizado

CRIT√âRIOS DE ACEITE:
- [ ] Documenta√ß√£o clara e completa.
- [ ] Exemplos pr√°ticos inclusos.
- [ ] Troubleshooting √∫til.

N√ÉO FAZER:
- N√£o fazer documenta√ß√£o muito t√©cnica para usu√°rios.
```

***

## Como Validar Localmente

Ap√≥s completar ETAPA 1-8, execute:

```bash
# 1. Type Check
npm run type-check
npm run lint

# 2. Testes
npm run test                    # Todos os testes
npm run test -- --coverage      # Com coverage

# 3. Build
npm run build

# 4. Dev Server (teste manual)
npm run dev
# Abrir http://localhost:5173

# 5. Teste Export/Import Manual
# - Criar algumas √°reas/conte√∫dos
# - Click Export ‚Üí download .bound file
# - Criar/modificar dados
# - Click Import ‚Üí selecionar arquivo ‚Üí escolher Merge
# - Verificar que dados antigos foram recuperados
# - Testar Replace strategy
# - Testar arquivo corrompido (deve rejeitar com erro claro)
```

***

## O que Deve Estar Acess√≠vel ao Final

- ‚úÖ **Export Funcional:**
  - Bot√£o Export no navbar
  - Download de arquivo .bound comprimido
  - Progress bar durante compress√£o
  - Toast de sucesso com file size
  - Filename: `bound-YYYY-MM-DD.bound`

- ‚úÖ **Import Funcional:**
  - Bot√£o Import no navbar
  - File input para .bound
  - ImportWizard com 4 steps:
    1. Valida√ß√£o de arquivo
    2. Sele√ß√£o de estrat√©gia (Replace/Merge/Selective)
    3. Preview de dados
    4. Confirma√ß√£o
  - Progress bar durante decompress/merge
  - Toast de sucesso/erro

- ‚úÖ **Merge Strategies:**
  - Replace: substitui todo o estado
  - Merge: adiciona novas √°reas, skipa duplicatas
  - Selective: usu√°rio escolhe quais √°reas importar

- ‚úÖ **Error Handling Robusto:**
  - Rejeita arquivos inv√°lidos com mensagens claras
  - Decompress failed ‚Üí mensagem √∫til
  - Corrupted data ‚Üí sugest√µes de a√ß√£o
  - Rollback em caso de erro

- ‚úÖ **UX Profissional:**
  - Progress bars durante opera√ß√µes
  - Toasts com feedback
  - Valida√ß√£o de arquivo antes de processar
  - File size formatado (1.2 MB, etc)
  - Timestamps em exports

- ‚úÖ **Performance:**
  - Compress√£o 70-90% do tamanho original
  - Export <2s para estado t√≠pico
  - Import <5s para arquivo t√≠pico
  - UI responsiva durante opera√ß√µes (async)

***

## Pr√≥xima Fase (Teaser)

**Fase 6: E2E Testing & Deployment**  
Implementaremos testes end-to-end com Playwright, covering completo de user workflows. Setup de CI/CD com GitHub Actions. Containeriza√ß√£o com Docker. Deployment para Vercel/Netlify. Performance testing e lighthouse audits. Ao final: aplica√ß√£o pronta para produ√ß√£o com teste automatizado e deployment cont√≠nuo.

***