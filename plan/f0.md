# üìÑ FASE 0: Setup, Tipos e Persist√™ncia (Funda√ß√£o)

## ESTRUTURA GERAL

A **Fase 0** estabelece a arquitetura t√©cnica e funda√ß√µes da aplica√ß√£o BOUND. Seu objetivo √© criar:
1. Um projeto Vite + React 18 + TypeScript completamente funcional e otimizado
2. Tipos de dom√≠nio rigorosos (interfaces, enums, type guards) que servir√£o como "contrato" para todas as fases seguintes
3. Um sistema de persist√™ncia robusto com versionamento de schema, permitindo evolu√ß√£o futura sem quebrar compatibilidade
4. Um validador de esquema e serializador para o formato `.bound`, testado e pronto para Fase 5

Ao final da Fase 0, voc√™ ter√° uma **funda√ß√£o s√≥lida** (types + storage) sem interface visual. Tudo ser√° validado por testes automatizados, garantindo que as pr√≥ximas fases possam se construir sobre uma base confi√°vel.

***

## FASE 0: Setup, Tipos e Persist√™ncia

### ETAPA 1: Inicializar Projeto Vite + React 18 + TypeScript

**Objetivo:**  
Criar projeto limpo com Vite, React 18, TypeScript configurado com strict mode, ESLint, Prettier, e script de build otimizado.

**Arquivos principais a tocar:**
- `package.json`
- `vite.config.ts`
- `tsconfig.json`
- `eslintrc.cjs` (ou `.eslintrc.json`)
- `.prettierrc`
- `src/main.tsx`
- `src/App.tsx`
- `index.html`

**Prompt para IA:**

```text
Voc√™ √© um engenheiro full-stack s√™nior especializado em frontend moderno.

TAREFA:
Criar um projeto Vite + React 18 + TypeScript do zero, com best practices de build e qualidade.

CONTEXTO IMPORTANTE:
- Projeto: BOUND (visualizador de v√≠nculos em grafo)
- Este √© o setup fundacional; precisamos de uma base s√≥lida para as pr√≥ximas fases.
- Nenhuma UI complexa por enquanto; apenas app shell m√≠nimo.
- Performance √© cr√≠tica: bundle target <500KB (gzipped) no final do projeto.

FUNCIONALIDADE DESEJADA:
1. Vite config com tree-shaking habilitado, minifica√ß√£o agressiva, chunk splitting para otimizar bundle.
2. React 18 com Strict Mode ativado (ajuda a detectar problemas).
3. TypeScript com `strict: true`, `noImplicitAny: true`, `noUnusedLocals: true`.
4. ESLint com regras React + TypeScript (recomenda√ß√£o: @typescript-eslint/recommended).
5. Prettier configurado e integrado ao ESLint.
6. Scripts npm: `dev`, `build`, `preview`, `lint`, `format`, `type-check`.
7. `.gitignore` apropriado.
8. Diret√≥rio `src/` com estrutura base: `src/components/`, `src/types/`, `src/utils/`, `src/store/`, `src/managers/`, `src/tests/`.
9. Um componente `App.tsx` minimalista que renderiza "BOUND App Ready" (apenas texto, sem estilo).
10. `index.html` com `<meta name="viewport" ...>` para mobile.

INSTRU√á√ïES T√âCNICAS:
1. Use `npm create vite@latest bound -- --template react-ts` como ponto de partida.
2. Instale depend√™ncias base: `react`, `react-dom`, `typescript`.
3. Instale dev dependencies: `vite`, `@vitejs/plugin-react`, `eslint`, `@typescript-eslint/eslint-plugin`, `@typescript-eslint/parser`, `prettier`, `eslint-config-prettier`, `vitest` (para testes unit√°rios), `@vitest/ui`.
4. Configure `vite.config.ts`:
   - `build.minify: 'terser'` com op√ß√µes agressivas.
   - `build.rollupOptions.output.manualChunks()` para code splitting (vendors, utils, etc.).
   - `build.reportCompressedSize: true` para feedback.
5. Configure `tsconfig.json`:
   - `"strict": true`
   - `"noImplicitAny": true`
   - `"noUnusedLocals": true`
   - `"noUnusedParameters": true`
   - `"resolveJsonModule": true`
6. Configure `.eslintrc.cjs`:
   ```javascript
   module.exports = {
     root: true,
     env: { browser: true, es2020: true },
     extends: [
       'eslint:recommended',
       'plugin:@typescript-eslint/recommended',
       'plugin:react-hooks/recommended',
       'prettier'
     ],
     ignorePatterns: ['dist', '.eslintignore'],
     parser: '@typescript-eslint/parser',
     plugins: ['react-refresh', '@typescript-eslint'],
     rules: {
       'react-refresh/only-export-components': 'warn',
       '@typescript-eslint/no-explicit-any': 'error',
     }
   };
   ```
7. Configure `.prettierrc`:
   ```json
   {
     "semi": true,
     "trailingComma": "all",
     "singleQuote": true,
     "printWidth": 100,
     "tabWidth": 2
   }
   ```
8. Crie `src/main.tsx`:
   ```typescript
   import React from 'react'
   import ReactDOM from 'react-dom/client'
   import App from './App'

   ReactDOM.createRoot(document.getElementById('root')!).render(
     <React.StrictMode>
       <App />
     </React.StrictMode>,
   )
   ```
9. Crie `src/App.tsx`:
   ```typescript
   export default function App() {
     return (
       <div>
         <h1>BOUND App Ready</h1>
       </div>
     )
   }
   ```
10. Crie diret√≥rios:
    - `src/components/`
    - `src/types/`
    - `src/utils/`
    - `src/store/`
    - `src/managers/`
    - `src/hooks/`
    - `src/tests/`

SA√çDA ESPERADA:
- Reposit√≥rio Git inicializado (com hist√≥rico limpo).
- `package.json` com todos os deps.
- `vite.config.ts`, `tsconfig.json`, `.eslintrc.cjs`, `.prettierrc` configurados.
- `src/` estrutura completa.
- `npm run dev` funciona (dev server em http://localhost:5173).
- `npm run build` gera `dist/` com bundle otimizado.
- `npm run lint` passa sem erros.
- `npm run type-check` (`tsc --noEmit`) passa sem erros.

CRIT√âRIOS DE ACEITE:
- [ ] `npm install` instala todas as deps sem erros.
- [ ] `npm run dev` inicia dev server sem erros.
- [ ] `npm run build` compila sem warnings/errors.
- [ ] TypeScript strict mode; `tsc --noEmit` passa.
- [ ] `npm run lint` sem erros/warnings.
- [ ] `npm run format` formata com Prettier sem erros.
- [ ] Bundle tamanho inicial (sem c√≥digo l√≥gica) <150KB gzipped.
- [ ] Nenhuma console warning ou erro em dev.

N√ÉO FAZER:
- N√£o adicionar Tailwind, Material-UI ou outras frameworks de UI ainda (Fase 4).
- N√£o criar l√≥gica de neg√≥cio (managers, state, etc.) ‚Äî apenas shell.
- N√£o configurar rotas (React Router ser√° Fase 4).
- N√£o implementar testes complexos (Fase 6).
```

***

### ETAPA 2: Definir Tipos de Dom√≠nio & Enums

**Objetivo:**  
Criar interfaces TypeScript r√≠gidas para Content, Area, Property, Shape, Link, Graph, que servir√£o como "single source of truth" para o projeto inteiro.

**Arquivos principais a tocar:**
- `src/types/index.ts` (main export)
- `src/types/enums.ts` (PropertyType, LinkType, ShapeType, etc.)
- `src/types/base.ts` (tipos utilit√°rios: Position, Color, Font, Dimension)
- `src/utils/validation.ts` (type guards: `isContent()`, `isArea()`, etc.)

**Prompt para IA:**

```text
Voc√™ √© um arquiteto de software com expertise em domain-driven design e TypeScript.

TAREFA:
Definir tipos de dom√≠nio (interfaces, enums, type guards) para a aplica√ß√£o BOUND. Estes tipos s√£o o "contrato" para todas as pr√≥ximas fases.

CONTEXTO IMPORTANTE:
- A aplica√ß√£o BOUND gerencia: Conte√∫dos (Content), √Åreas (Area), Propriedades (Property), Formas (Shape), Links (Link), Posi√ß√µes no Grafo (NodePosition).
- Tipos devem ser imut√°veis (n√£o use mutabilidade, use `readonly` onde apropriado).
- Cada tipo deve ser valid√°vel (criar type guards).
- Enums e constantes devem ser claramente separados de interfaces.
- Exemplo de fluxo: Content (aberto) ‚Üí user desenha shapes, adiciona propriedades ‚Üí Content (fechado) ‚Üí vira n√≥ no grafo.

FUNCIONALIDADE DESEJADA:
1. **Tipos Base/Utilit√°rios:**
   - `Position { x: number; y: number }`
   - `Dimension { width: number; height: number }`
   - `Color { r: number; g: number; b: number; a?: number }` ou `colorHex: string`
   - `FontStyle { fontFamily: string; fontSize: number; fontWeight?: number; color: string }`

2. **Enums:**
   - `PropertyType = 'tag' | 'date' | 'shortText' | 'longText' | 'number' | 'link'`
   - `LinkType = 'manual' | 'auto'` (manual vs autom√°tico via propriedade)
   - `ShapeType = 'rect' | 'circle' | 'line' | 'arrow' | 'text'`
   - `ContentStatus = 'open' | 'closed'` (aberto para editar vs fechado = n√≥ no grafo)

3. **Propriedade (Property):**
   ```typescript
   interface Property {
     id: string;
     name: string; // "Data de Cria√ß√£o", "Link para...", etc.
     type: PropertyType;
     value: unknown; // depende do tipo
     createdAt: number;
   }
   ```

4. **Shape (desenho no canvas):**
   ```typescript
   interface Shape {
     id: string;
     type: ShapeType;
     position: Position;
     dimension: Dimension;
     style: {
       fill?: string;
       stroke?: string;
       strokeWidth?: number;
       fontStyle?: FontStyle;
       opacity?: number;
     };
     content?: string; // para "text" shapes
     createdAt: number;
   }
   ```

5. **Content (conte√∫do principal):**
   ```typescript
   interface Content {
     id: string;
     areaId: string; // FK para Area
     title: string;
     status: ContentStatus; // 'open' | 'closed'
     body: {
       shapes: Shape[];
     };
     properties: Property[]; // propriedades customiz√°veis
     emoji?: string;
     nodePosition?: Position; // posi√ß√£o no grafo (apenas se status='closed')
     createdAt: number;
     updatedAt: number;
   }
   ```

6. **Link (conex√£o entre dois n√≥s):**
   ```typescript
   interface Link {
     id: string;
     fromContentId: string;
     toContentId: string;
     type: LinkType; // 'manual' | 'auto' (auto = criado por Property.type='link')
     propertyId?: string; // se auto, qual propriedade gerou
     createdAt: number;
   }
   ```

7. **Area (agrupamento):**
   ```typescript
   interface Area {
     id: string;
     name: string; // √∫nico por sess√£o
     description?: string;
     contentIds: string[]; // FK array para Content
     backgroundColor?: string; // cor de fundo (modo escuro)
     createdAt: number;
     updatedAt: number;
   }
   ```

8. **Grafo (resultado do fechamento de conte√∫dos):**
   ```typescript
   interface GraphNode {
     id: string; // = Content.id
     contentId: string;
     position: Position;
     title: string;
     emoji?: string;
   }

   interface GraphEdge {
     id: string;
     from: string; // Content.id
     to: string;   // Content.id
     linkId: string; // FK para Link
     type: LinkType;
   }

   interface Graph {
     nodes: GraphNode[];
     edges: GraphEdge[];
   }
   ```

9. **Aplica√ß√£o (State global):**
   ```typescript
   interface AppState {
     areas: Area[];
     contents: Content[];
     links: Link[];
     graph?: Graph; // computed, n√£o persistido
     currentAreaId?: string;
     currentContentId?: string;
     version: number; // SCHEMA_VERSION
   }
   ```

10. **Type Guards (validadores):**
    - `isContent(obj: unknown): obj is Content`
    - `isArea(obj: unknown): obj is Area`
    - `isProperty(obj: unknown): obj is Property`
    - `isShape(obj: unknown): obj is Shape`
    - `isLink(obj: unknown): obj is Link`
    - `isAppState(obj: unknown): obj is AppState`
    - Exemplo:
      ```typescript
      export function isContent(obj: unknown): obj is Content {
        if (typeof obj !== 'object' || obj === null) return false;
        const c = obj as Record<string, unknown>;
        return (
          typeof c.id === 'string' &&
          typeof c.areaId === 'string' &&
          typeof c.title === 'string' &&
          (c.status === 'open' || c.status === 'closed') &&
          Array.isArray(c.properties) &&
          typeof c.createdAt === 'number'
        );
      }
      ```

INSTRU√á√ïES T√âCNICAS:
1. Crie `src/types/enums.ts`:
   - Exporte const objects como "nominal types" (ex: `const PropertyType = { ... }`)
   - Ou use `enum PropertyType { TAG = 'tag', DATE = 'date', ... }`

2. Crie `src/types/base.ts`:
   - Tipos utilit√°rios (Position, Dimension, Color, FontStyle).
   - Export consts com defaults (ex: `DEFAULT_FONT_FAMILY = 'Arial'`).

3. Crie `src/types/index.ts`:
   - Reexporte tudo (Content, Area, Property, Shape, Link, Graph, AppState, PropertyType, LinkType, ShapeType, ContentStatus).
   - Seja exaustivo (use `export type { Content, Area, ... }` e `export { PropertyType, ... }`).

4. Crie `src/utils/validation.ts`:
   - Implemente todos os type guards.
   - Use pattern de verifica√ß√£o defensiva.

5. **Testes** (`src/types/index.test.ts`):
   - Teste cada type guard com valores v√°lidos e inv√°lidos.
   - Exemplo:
     ```typescript
     describe('Type Guards', () => {
       it('isContent should validate correct Content', () => {
         const valid: Content = { ... };
         expect(isContent(valid)).toBe(true);
       });
       it('isContent should reject invalid object', () => {
         expect(isContent({ foo: 'bar' })).toBe(false);
       });
     });
     ```

6. Estrutura de diret√≥rios:
   ```
   src/
   ‚îú‚îÄ‚îÄ types/
   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts           (main export)
   ‚îÇ   ‚îú‚îÄ‚îÄ base.ts            (Position, Dimension, Color, FontStyle)
   ‚îÇ   ‚îú‚îÄ‚îÄ enums.ts           (PropertyType, LinkType, etc.)
   ‚îÇ   ‚îú‚îÄ‚îÄ content.ts         (Content interface)
   ‚îÇ   ‚îú‚îÄ‚îÄ area.ts            (Area interface)
   ‚îÇ   ‚îú‚îÄ‚îÄ property.ts        (Property interface)
   ‚îÇ   ‚îú‚îÄ‚îÄ shape.ts           (Shape interface)
   ‚îÇ   ‚îú‚îÄ‚îÄ link.ts            (Link interface)
   ‚îÇ   ‚îú‚îÄ‚îÄ graph.ts           (Graph, GraphNode, GraphEdge)
   ‚îÇ   ‚îú‚îÄ‚îÄ app.ts             (AppState)
   ‚îÇ   ‚îî‚îÄ‚îÄ index.test.ts      (testes type guards)
   ‚îî‚îÄ‚îÄ utils/
       ‚îî‚îÄ‚îÄ validation.ts      (type guards)
   ```

SA√çDA ESPERADA:
- `src/types/index.ts` exporting all types.
- `src/types/enums.ts` com todos os enums.
- `src/types/base.ts` com tipos utilit√°rios.
- `src/utils/validation.ts` com type guards.
- `src/types/index.test.ts` com cobertura >90%.
- Arquivo documenta√ß√£o (`types/README.md`) explicando cada tipo e seu ciclo de vida.

CRIT√âRIOS DE ACEITE:
- [ ] `npm run type-check` passa sem erros (TypeScript strict).
- [ ] Todos os tipos s√£o exportados de `src/types/index.ts`.
- [ ] Type guards cobrem todos os tipos principais.
- [ ] Testes de type guards passam (`npm run test`).
- [ ] Sem `any` ou `unknown` sem tratamento (exceto em validadores).
- [ ] README.md documenta ciclo de vida: Content (open) ‚Üí shapes/properties ‚Üí (closed) ‚Üí n√≥ grafo.

N√ÉO FAZER:
- N√£o implementar l√≥gica de neg√≥cio (managers, c√°lculos).
- N√£o criar tipos para UI (componentes). Types s√£o apenas dom√≠nio.
- N√£o usar tipos "gen√©ricos demais" (ex: `Record<string, any>`); seja expl√≠cito.
```

***

### ETAPA 3: Implementar LocalStorage Adapter & Versionamento Schema

**Objetivo:**  
Criar camada de persist√™ncia robusto com versionamento de schema, migrations, e adapters (LocalStorage + IndexedDB fallback).

**Arquivos principais a tocar:**
- `src/constants/schema.ts`
- `src/store/storage.ts`
- `src/store/migrations.ts`
- `src/types/storage.ts`

**Prompt para IA:**

```text
Voc√™ √© um engenheiro backend/fullstack especializado em dados e persist√™ncia.

TAREFA:
Implementar sistema robusto de persist√™ncia com versionamento de schema e migrations para a aplica√ß√£o BOUND.

CONTEXTO IMPORTANTE:
- A aplica√ß√£o precisa rodar offline, no navegador do usu√°rio.
- Estado completo (AppState: areas, contents, links) deve ser persistido em LocalStorage (prim√°rio) com IndexedDB (fallback para arquivos grandes).
- Schema pode evoluir (v1 ‚Üí v2 ‚Üí v3). Precisamos de migrations autom√°ticas.
- Compatibilidade retroativa: aplica√ß√£o nova abre arquivo .bound de vers√£o antiga sem perder dados.
- Performance: read/write <100ms para estado t√≠pico (~100 conte√∫dos).

FUNCIONALIDADE DESEJADA:
1. **Schema Version Management:**
   - `SCHEMA_VERSION = 1` (constante em `src/constants/schema.ts`).
   - Estrutura default (template vazio): `{ version: 1, areas: [], contents: [], links: [], graph: null, currentAreaId: null, ... }`.
   - Cada record tem `createdAt`, `updatedAt` timestamps.

2. **Storage Adapter (Abstra√ß√£o):**
   ```typescript
   interface StorageAdapter {
     get(key: string): Promise<AppState | null>;
     set(key: string, value: AppState): Promise<void>;
     remove(key: string): Promise<void>;
     clear(): Promise<void>;
     getSize(): Promise<number>; // em bytes
   }
   ```

3. **LocalStorageAdapter:**
   - Key: `bound:app-state` (prefixo para namespace).
   - Serializa√ß√£o: `JSON.stringify()` direto (sem compress√£o ainda).
   - Valida√ß√£o: antes de persistir, validar schema com type guards.
   - Limite: ~5-10MB; se exceder, cai back para IndexedDB ou compress√£o.

4. **IndexedDBAdapter (Fallback):**
   - DB: `boundDB`, store: `appState`.
   - √çndices: nenhum (simples).
   - Fallback autom√°tico se LocalStorage cheio.

5. **Migration System:**
   ```typescript
   type Migration = (state: any) => AppState;

   const migrations: Record<number, Migration> = {
     1: (state) => state, // v1 = identity (novo app)
     2: (state) => { /* se houver v2 */ },
   };

   function migrateState(state: any, fromVersion: number): AppState {
     let current = state;
     for (let v = fromVersion + 1; v <= SCHEMA_VERSION; v++) {
       if (migrations[v]) {
         current = migrations[v](current);
       }
     }
     return current;
   }
   ```

6. **Storage Manager (wrapper):**
   ```typescript
   class StorageManager {
     adapter: StorageAdapter;
     
     async load(): Promise<AppState> {
       let raw = await adapter.get('bound:app-state');
       if (!raw) return getDefaultState();
       if (raw.version < SCHEMA_VERSION) {
         raw = migrateState(raw, raw.version);
       }
       return raw;
     }

     async save(state: AppState): Promise<void> {
       if (!isAppState(state)) throw new Error('Invalid AppState');
       await adapter.set('bound:app-state', state);
     }
   }
   ```

7. **Valida√ß√£o de Integridade:**
   - Antes de salvar: validar com `isAppState()` type guard.
   - Antes de carregar: validar e repairar se necess√°rio (ex: remover `undefined` fields).
   - Log de errors (console.warn) mas n√£o quebrar app.

8. **LocalStorage Quotas:**
   - Detectar exce√ß√£o `QuotaExceededError`.
   - Fallback autom√°tico para IndexedDB.
   - Avisar user: "Estado grande, usando IndexedDB" (toast em Fase 4).

INSTRU√á√ïES T√âCNICAS:
1. Crie `src/constants/schema.ts`:
   ```typescript
   export const SCHEMA_VERSION = 1;
   export const STORAGE_KEY = 'bound:app-state';
   
   export function getDefaultState(): AppState {
     return {
       version: SCHEMA_VERSION,
       areas: [],
       contents: [],
       links: [],
       graph: null,
       currentAreaId: undefined,
       currentContentId: undefined,
       createdAt: Date.now(),
       updatedAt: Date.now(),
     };
   }
   ```

2. Crie `src/types/storage.ts`:
   ```typescript
   export interface StorageAdapter {
     get(key: string): Promise<AppState | null>;
     set(key: string, value: AppState): Promise<void>;
     remove(key: string): Promise<void>;
     clear(): Promise<void>;
     getSize(): Promise<number>;
   }
   ```

3. Crie `src/store/storage.ts`:
   ```typescript
   // LocalStorageAdapter
   export class LocalStorageAdapter implements StorageAdapter {
     async get(key: string): Promise<AppState | null> {
       const raw = localStorage.getItem(key);
       if (!raw) return null;
       try {
         return JSON.parse(raw) as AppState;
       } catch (e) {
         console.warn('Failed to parse LocalStorage', e);
         return null;
       }
     }

     async set(key: string, value: AppState): Promise<void> {
       try {
         localStorage.setItem(key, JSON.stringify(value));
       } catch (e) {
         if ((e as any).name === 'QuotaExceededError') {
           console.warn('LocalStorage quota exceeded, falling back to IndexedDB');
           // Delegate to IndexedDB (implementar em pr√≥xima etapa)
           throw e;
         }
         throw e;
       }
     }

     async remove(key: string): Promise<void> {
       localStorage.removeItem(key);
     }

     async clear(): Promise<void> {
       localStorage.clear();
     }

     async getSize(): Promise<number> {
       let size = 0;
       for (const key in localStorage) {
         if (localStorage.hasOwnProperty(key)) {
           size += localStorage[key].length;
         }
       }
       return size;
     }
   }
   ```

4. Crie `src/store/migrations.ts`:
   ```typescript
   export type Migration = (state: any) => AppState;

   export const migrations: Record<number, Migration> = {
     1: (state) => {
       // v1: identity, novo app
       if (!state.version) state.version = 1;
       return state as AppState;
     },
   };

   export function migrateState(state: any, fromVersion: number): AppState {
     if (fromVersion >= SCHEMA_VERSION) return state;
     let current = state;
     for (let v = fromVersion + 1; v <= SCHEMA_VERSION; v++) {
       if (migrations[v]) {
         current = migrations[v](current);
       }
     }
     return current;
   }
   ```

5. Crie `src/store/storageManager.ts`:
   ```typescript
   export class StorageManager {
     private adapter: StorageAdapter;

     constructor(adapter: StorageAdapter) {
       this.adapter = adapter;
     }

     async load(): Promise<AppState> {
       const raw = await this.adapter.get(STORAGE_KEY);
       if (!raw) {
         return getDefaultState();
       }
       
       // Validar schema version
       if (raw.version < SCHEMA_VERSION) {
         console.log(`Migrating from v${raw.version} to v${SCHEMA_VERSION}`);
         return migrateState(raw, raw.version);
       }

       // Validar integridade
       if (!isAppState(raw)) {
         console.warn('Corrupted AppState, resetting');
         return getDefaultState();
       }

       return raw;
     }

     async save(state: AppState): Promise<void> {
       if (!isAppState(state)) {
         throw new Error(`Invalid AppState: ${JSON.stringify(state)}`);
       }
       state.updatedAt = Date.now();
       await this.adapter.set(STORAGE_KEY, state);
     }

     async clear(): Promise<void> {
       await this.adapter.clear();
     }

     async getSize(): Promise<number> {
       return this.adapter.getSize();
     }
   }
   ```

6. Testes (`src/store/storage.test.ts`):
   ```typescript
   describe('StorageManager', () => {
     it('should load default state if empty', async () => {
       const adapter = new LocalStorageAdapter();
       await adapter.clear();
       const manager = new StorageManager(adapter);
       const state = await manager.load();
       expect(state.version).toBe(1);
       expect(state.areas).toEqual([]);
     });

     it('should save and load state', async () => {
       const adapter = new LocalStorageAdapter();
       const manager = new StorageManager(adapter);
       const state = getDefaultState();
       state.areas.push({ id: '1', name: 'Test', contentIds: [], createdAt: Date.now(), updatedAt: Date.now() });
       
       await manager.save(state);
       const loaded = await manager.load();
       expect(loaded.areas).toHaveLength(1);
       expect(loaded.areas.name).toBe('Test');
     });

     it('should migrate state from older version', async () => {
       const adapter = new LocalStorageAdapter();
       const oldState = { version: 0, areas: [] };
       await adapter.set(STORAGE_KEY, oldState);
       
       const manager = new StorageManager(adapter);
       const loaded = await manager.load();
       expect(loaded.version).toBe(SCHEMA_VERSION);
     });

     it('should reject invalid state', async () => {
       const manager = new StorageManager(new LocalStorageAdapter());
       const invalidState = { foo: 'bar' } as any;
       await expect(manager.save(invalidState)).rejects.toThrow();
     });
   });
   ```

7. Estrutura de diret√≥rios:
   ```
   src/
   ‚îú‚îÄ‚îÄ constants/
   ‚îÇ   ‚îî‚îÄ‚îÄ schema.ts
   ‚îú‚îÄ‚îÄ store/
   ‚îÇ   ‚îú‚îÄ‚îÄ storage.ts          (adapters)
   ‚îÇ   ‚îú‚îÄ‚îÄ migrations.ts       (migration functions)
   ‚îÇ   ‚îú‚îÄ‚îÄ storageManager.ts   (manager)
   ‚îÇ   ‚îî‚îÄ‚îÄ storage.test.ts     (testes)
   ‚îî‚îÄ‚îÄ types/
       ‚îî‚îÄ‚îÄ storage.ts
   ```

SA√çDA ESPERADA:
- `src/store/storageManager.ts` com `StorageManager` class.
- `src/store/storage.ts` com `LocalStorageAdapter`.
- `src/store/migrations.ts` com migration template.
- `src/constants/schema.ts` com `SCHEMA_VERSION` e `getDefaultState()`.
- `src/store/storage.test.ts` com testes (>80% coverage).
- README.md em `src/store/` explicando versionamento e migrations.

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test` passa em `storage.test.ts`.
- [ ] `StorageManager.load()` retorna default state se vazio.
- [ ] `StorageManager.save()` persiste em LocalStorage.
- [ ] Roundtrip: save ‚Üí load ‚Üí equals (sem perda).
- [ ] Valida√ß√£o: rejeita AppState inv√°lido (sem type guards).
- [ ] Migra√ß√£o: v0 ‚Üí v1 (ou v1 ‚Üí v1 se j√° v1).
- [ ] TypeScript: sem erros com `strict: true`.

N√ÉO FAZER:
- N√£o implementar compress√£o ainda (Fase 5).
- N√£o usar callbacks (async/await apenas).
- N√£o fazer UI; apenas l√≥gica de storage.
```

***

### ETAPA 4: Implementar Serializador para Formato .bound

**Objetivo:**  
Criar encoder/decoder para formato `.bound` (arquivo que o user baixa/importa), permitindo roundtrip perfeito: state ‚Üí .bound ‚Üí state.

**Arquivos principais a tocar:**
- `src/utils/serialization.ts`
- `src/types/bound.ts`
- `src/utils/validation/boundValidator.ts`

**Prompt para IA:**

```text
Voc√™ √© um especialista em serializa√ß√£o de dados e formatos bin√°rios.

TAREFA:
Implementar serializador/desserializador para formato `.bound` (arquivo que user exporta/importa). O arquivo deve:
1. Conter estado completo da aplica√ß√£o (AppState).
2. Ser valid√°vel (checksum/vers√£o).
3. Ser humano-leg√≠vel se necess√°rio (JSON), mas comprim√≠vel.
4. Suportar round-trip perfeito sem perda de dados.

CONTEXTO IMPORTANTE:
- Formato v1: JSON + gzip (simples, pronto agora).
- Formato futuro (v2): MessagePack ou Protobuf (mais eficiente).
- Arquivo baixado com nome: `bound-{timestamp}.bound`.
- User pode importar: arquivo ‚Üí parsear ‚Üí validar ‚Üí aplicar (replace ou merge).
- Integridade: incluir checksum (SHA256 ou MD5 da payload).

FUNCIONALIDADE DESEJADA:
1. **BoundFile Interface:**
   ```typescript
   interface BoundFile {
     version: number; // 1
     schemaVersion: number; // SCHEMA_VERSION
     createdAt: number;
     checksum: string; // SHA256 da payload
     payload: AppState; // AppState serializado
   }
   ```

2. **Encoder (state ‚Üí JSON):**
   - Input: `AppState`
   - Output: JSON string (ou gzip binary)
   - Valida√ß√£o: tipo-check antes de serializar
   - Checksum: SHA256 da payload (implementar ou usar `crypto.subtle`)

3. **Decoder (JSON ‚Üí state):**
   - Input: arquivo `.bound` (string ou arquivo binary)
   - Output: `AppState`
   - Valida√ß√£o: checksum, schema version, type guards
   - Error handling: arquivo corrompido, vers√£o incompat√≠vel, etc.

4. **Compression (opcional para v1, mas estrutura preparada):**
   - Use `pako` (zlib em JS) ou `lz4-wasm`.
   - Estrutura de encoder:
     ```typescript
     function encode(state: AppState, compress: boolean = true): string {
       const payload = JSON.stringify(state);
       const checksum = sha256(payload);
       const file: BoundFile = {
         version: 1,
         schemaVersion: SCHEMA_VERSION,
         createdAt: Date.now(),
         checksum,
         payload: compress ? gzip(payload) : payload,
       };
       return JSON.stringify(file);
     }
     ```

INSTRU√á√ïES T√âCNICAS:
1. Crie `src/types/bound.ts`:
   ```typescript
   export interface BoundFile {
     version: number;
     schemaVersion: number;
     createdAt: number;
     checksum: string;
     payload: AppState | string; // string se gzipped
   }

   export type BoundExportOptions = {
     compress?: boolean; // v1 default: true
   };

   export type BoundImportOptions = {
     mergePolicy?: 'replace' | 'merge'; // replace = limpar, merge = adicionar
   };
   ```

2. Crie `src/utils/serialization.ts`:
   ```typescript
   import { sha256 } from 'crypto-js'; // ou usar crypto.subtle nativo

   export class BoundSerializer {
     static async encode(
       state: AppState,
       options?: BoundExportOptions,
     ): Promise<string> {
       if (!isAppState(state)) {
         throw new Error('Invalid AppState');
       }

       const payload = JSON.stringify(state);
       const checksum = await this.calculateChecksum(payload);

       const file: BoundFile = {
         version: 1,
         schemaVersion: SCHEMA_VERSION,
         createdAt: Date.now(),
         checksum,
         payload: options?.compress ? await this.compress(payload) : payload,
       };

       return JSON.stringify(file);
     }

     static async decode(fileContent: string): Promise<AppState> {
       let file: BoundFile;
       try {
         file = JSON.parse(fileContent);
       } catch (e) {
         throw new Error(`Failed to parse .bound file: ${e}`);
       }

       // Validar schema
       if (file.version !== 1) {
         throw new Error(`Unsupported BoundFile version: ${file.version}`);
       }

       // Descomprimir se necess√°rio
       let payload: string;
       if (typeof file.payload === 'string' && file.payload.startsWith('H4sI')) {
         // gzip magic header
         payload = await this.decompress(file.payload);
       } else {
         payload = typeof file.payload === 'string' ? file.payload : JSON.stringify(file.payload);
       }

       // Validar checksum
       const calculatedChecksum = await this.calculateChecksum(payload);
       if (calculatedChecksum !== file.checksum) {
         throw new Error('Checksum mismatch: file corrupted');
       }

       // Parse state
       let state: AppState;
       try {
         state = JSON.parse(payload);
       } catch (e) {
         throw new Error(`Failed to parse state payload: ${e}`);
       }

       // Validar integridade
       if (!isAppState(state)) {
         throw new Error('Invalid AppState in .bound file');
       }

       // Migrar se necess√°rio
       if (state.version < SCHEMA_VERSION) {
         state = migrateState(state, state.version);
       }

       return state;
     }

     private static async calculateChecksum(data: string): Promise<string> {
       const encoder = new TextEncoder();
       const hashBuffer = await crypto.subtle.digest('SHA-256', encoder.encode(data));
       return Array.from(new Uint8Array(hashBuffer))
         .map((b) => b.toString(16).padStart(2, '0'))
         .join('');
     }

     private static async compress(data: string): Promise<string> {
       // Usar pako.gzip (instalar: npm install pako)
       const compressed = await import('pako').then((p) => p.gzip(data));
       return Buffer.from(compressed).toString('base64');
     }

     private static async decompress(data: string): Promise<string> {
       const decompressed = await import('pako').then((p) =>
         p.ungzip(Buffer.from(data, 'base64'), { to: 'string' }),
       );
       return decompressed;
     }
   }
   ```

3. Crie `src/utils/validation/boundValidator.ts`:
   ```typescript
   export function isBoundFile(obj: unknown): obj is BoundFile {
     if (typeof obj !== 'object' || obj === null) return false;
     const f = obj as Record<string, unknown>;
     return (
       f.version === 1 &&
       typeof f.schemaVersion === 'number' &&
       typeof f.createdAt === 'number' &&
       typeof f.checksum === 'string' &&
       (typeof f.payload === 'string' || typeof f.payload === 'object')
     );
   }

   export function validateBoundFile(file: BoundFile): string[] {
     const errors: string[] = [];
     if (file.version !== 1) errors.push('Unsupported version');
     if (file.checksum.length !== 64) errors.push('Invalid checksum format');
     if (file.createdAt > Date.now()) errors.push('File creation time in future');
     return errors;
   }
   ```

4. Instale depend√™ncias:
   ```bash
   npm install pako
   npm install --save-dev @types/pako
   ```

5. Testes (`src/utils/serialization.test.ts`):
   ```typescript
   describe('BoundSerializer', () => {
     it('should encode state to .bound format', async () => {
       const state = getDefaultState();
       const encoded = await BoundSerializer.encode(state);
       expect(encoded).toContain('"version":1');
       expect(encoded).toContain('"checksum"');
     });

     it('should decode .bound file to state', async () => {
       const state = getDefaultState();
       state.areas.push({ id: '1', name: 'Test', contentIds: [], createdAt: Date.now(), updatedAt: Date.now() });
       const encoded = await BoundSerializer.encode(state);
       const decoded = await BoundSerializer.decode(encoded);
       expect(decoded.areas).toHaveLength(1);
       expect(decoded.areas.name).toBe('Test');
     });

     it('should reject corrupted checksum', async () => {
       const state = getDefaultState();
       const encoded = await BoundSerializer.encode(state);
       const file = JSON.parse(encoded);
       file.checksum = 'invalid';
       await expect(BoundSerializer.decode(JSON.stringify(file))).rejects.toThrow('Checksum mismatch');
     });

     it('should handle compression', async () => {
       const state = getDefaultState();
       const encoded = await BoundSerializer.encode(state, { compress: true });
       const decoded = await BoundSerializer.decode(encoded);
       expect(decoded.areas).toEqual(state.areas);
     });
   });
   ```

6. Estrutura:
   ```
   src/
   ‚îú‚îÄ‚îÄ types/
   ‚îÇ   ‚îî‚îÄ‚îÄ bound.ts
   ‚îú‚îÄ‚îÄ utils/
   ‚îÇ   ‚îú‚îÄ‚îÄ serialization.ts
   ‚îÇ   ‚îú‚îÄ‚îÄ validation/
   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ boundValidator.ts
   ‚îÇ   ‚îî‚îÄ‚îÄ serialization.test.ts
   ```

SA√çDA ESPERADA:
- `src/utils/serialization.ts` com `BoundSerializer` class (encode, decode).
- `src/types/bound.ts` com `BoundFile` interface.
- `src/utils/validation/boundValidator.ts` com validadores.
- `src/utils/serialization.test.ts` com cobertura >85%.
- Arquivo `.bound` gerado pode ser salvo/carregado sem perda.

CRIT√âRIOS DE ACEITE:
- [ ] `encode(state)` retorna string JSON v√°lida.
- [ ] `decode(encoded)` retorna state equivalente ao original.
- [ ] Roundtrip: `decode(encode(state)) === state` (sem perda).
- [ ] Checksum validado (corrupto = erro).
- [ ] Compress√£o funciona (arquivo menor se comprimido).
- [ ] Testes passam (>85% coverage).
- [ ] TypeScript strict, sem erros.

N√ÉO FAZER:
- N√£o implementar merge logic ainda (Fase 5, import).
- N√£o usar formatos bin√°rios (v1 √© JSON; v2+ pode ser binary).
- N√£o fazer UI download/upload (s√≥ l√≥gica).
```

***

## Como Validar Localmente

Ap√≥s completar ETAPA 1-4, execute:

```bash
# 1. Setup
npm install
npm run dev          # Vite dev server (http://localhost:5173)

# 2. Type Check
npm run type-check   # tsc --noEmit (deve passar sem erros)
npm run lint         # ESLint (deve passar)

# 3. Testes
npm run test         # Vitest (types, storage, serialization)
npm run test:ui      # Vitest UI (visual feedback)

# 4. Build
npm run build        # Produ√ß√£o (dist/)
npm run preview      # Preview da build

# 5. Bundle size
npm run build -- --analyze  # (se configurado webpack-bundle-analyzer)
```

***

## O que Deve Estar Acess√≠vel na UI ao Final

**Nenhuma UI complexa na Fase 0.** Apenas:
- ‚úÖ App compila e roda (`npm run dev`)
- ‚úÖ Console: sem erros
- ‚úÖ `<h1>BOUND App Ready</h1>` renderizado
- ‚úÖ Tipos/valida√ß√£o/storage/serializa√ß√£o **testados** (n√£o vis√≠veis, mas acess√≠veis via API interna)

***

## Pr√≥xima Fase (Teaser)

**Fase 1: Core Logic & State Management**  
Implementaremos managers (ContentManager, AreaManager, PropertyManager, LinkManager) e Zustand store que consome o storage da Fase 0. Sem UI ainda; apenas hooks e l√≥gica de neg√≥cio testada. Ao final: `useContent()`, `useArea()`, `useGraph()` funcionais.

***

**Fim da Fase 0. Ap√≥s validar localmente com sucesso, responda `FASE 0 VALIDADA` para que eu gere o arquivo da Fase 1.**