# üìÑ FASE 1: Core Logic & State Management

## ESTRUTURA GERAL

A **Fase 1** implementa a l√≥gica de neg√≥cio (business logic) e gerenciamento de estado da aplica√ß√£o BOUND. Seu objetivo √© criar:

1. **Managers** (ContentManager, AreaManager, PropertyManager, LinkManager) que encapsulam opera√ß√µes de CRUD e regras de neg√≥cio
2. **Zustand Store** global que persiste estado em LocalStorage (usando adaptador da Fase 0)
3. **Hooks customizados** (`useContent`, `useArea`, `useGraph`, `useNavigation`) que exp√µem a l√≥gica aos componentes React
4. **Testes unit√°rios** abrangentes de l√≥gica, sem depender de UI

Ao final da Fase 1, voc√™ ter√° uma **camada de l√≥gica s√≥lida e independente de UI**, totalmente testada, pronta para ser consumida pelos componentes das pr√≥ximas fases. Nenhuma UI ainda; apenas APIs (functions e hooks) que a UI chamar.

***

## FASE 1: Core Logic & State Management

### ETAPA 1: Implementar ContentManager

**Objetivo:**  
Criar manager que encapsula opera√ß√µes CRUD em conte√∫dos (Content), incluindo abrir/fechar, adicionar propriedades, validar estado.

**Arquivos principais a tocar:**
- `src/managers/ContentManager.ts`
- `src/managers/index.ts` (export)
- `src/managers/ContentManager.test.ts`

**Prompt para IA:**

```text
Voc√™ √© um engenheiro de software s√™nior especializado em domain logic e design patterns.

TAREFA:
Implementar `ContentManager`: uma classe que centraliza toda a l√≥gica de CRUD de conte√∫dos (Content) na aplica√ß√£o BOUND, garantindo imutabilidade, valida√ß√£o, e invariantes de neg√≥cio.

CONTEXTO IMPORTANTE:
- Content tem ciclo de vida: open ‚Üí user edita (shapes, propriedades) ‚Üí closed (vira n√≥ no grafo).
- Ao criar Content, deve ser atribu√≠do a uma Area.
- Ao fechar Content, deve-se calcular posi√ß√£o no grafo (ou deixar `undefined` at√© grafo renderizar).
- ContentManager √© stateless; recebe estado como par√¢metro, retorna novo estado (functional style).
- Todas opera√ß√µes s√£o imut√°veis (spread, concat, sem muta√ß√£o direta).
- Cada opera√ß√£o valida pr√©-condi√ß√µes (ex: Area existe) e p√≥s-condi√ß√µes (ex: Content criado tem ID √∫nico).

FUNCIONALIDADE DESEJADA:

1. **createContent(areaId: string, title: string, state: AppState): Content**
   - Criar novo Content com ID gerado (uuid ou nanoid), status='open', body.shapes=[], properties=[], emoji=undefined.
   - Validar: areaId existe em state.areas.
   - Retornar novo Content (sem adicionar a state ainda; manager √© stateless).

2. **updateContent(contentId: string, updates: Partial<Content>, state: AppState): Content**
   - Atualizar title, emoji, ou qualquer outro campo.
   - Validar: contentId existe, updates n√£o quebram invariantes.
   - Retornar Content atualizado (sem mutar original).

3. **deleteContent(contentId: string, state: AppState): { success: boolean; reason?: string }**
   - Deletar Content.
   - Side effect: remover de Area.contentIds, remover todos os Links associados.
   - Validar: contentId existe.
   - Retornar { success: true } ou { success: false, reason: 'Content not found' }.

4. **openContent(contentId: string, state: AppState): Content**
   - Mudar status de 'closed' para 'open'.
   - Limpar nodePosition (grafo recalcular√° ao fechar novamente).
   - Validar: contentId existe.

5. **closeContent(contentId: string, state: AppState): Content**
   - Mudar status de 'open' para 'closed'.
   - Pode-se deixar nodePosition undefined (ser√° calculado em GraphManager).
   - Validar: contentId existe, est√° open.

6. **addShapeToContent(contentId: string, shape: Shape, state: AppState): Content**
   - Adicionar Shape ao body.shapes.
   - Validar: shape.id √© √∫nico dentro deste Content.
   - Retornar Content com novo shape adicionado.

7. **removeShapeFromContent(contentId: string, shapeId: string, state: AppState): Content**
   - Remover Shape do body.shapes.
   - Validar: Shape existe.

8. **updateShapeInContent(contentId: string, shapeId: string, updates: Partial<Shape>, state: AppState): Content**
   - Atualizar propriedades de um Shape (posi√ß√£o, cor, etc.).
   - Validar: Shape existe.

9. **addPropertyToContent(contentId: string, property: Property, state: AppState): Content**
   - Adicionar Property ao conte√∫do.
   - Validar: property.id √© √∫nico dentro deste Content, property.name √© v√°lido.
   - Se property.type = 'link', criar Link autom√°tico (delegado a LinkManager).

10. **removePropertyFromContent(contentId: string, propertyId: string, state: AppState): Content**
    - Remover Property.
    - Validar: Property existe.

11. **updatePropertyInContent(contentId: string, propertyId: string, updates: Partial<Property>, state: AppState): Content**
    - Atualizar nome, tipo, valor de uma Property.
    - Validar: Property existe, novo tipo √© compat√≠vel.

12. **getContentById(contentId: string, state: AppState): Content | undefined**
    - Retornar conte√∫do por ID (helper, n√£o modifica estado).

13. **getContentsByAreaId(areaId: string, state: AppState): Content[]**
    - Retornar todos os conte√∫dos de uma √°rea (helper).

14. **validateContent(content: Content): string[]**
    - Retornar array de erros de valida√ß√£o (se houver).
    - Exemplos: "title is empty", "properties have duplicate IDs", etc.

INSTRU√á√ïES T√âCNICAS:

1. Estrutura base de ContentManager:
   ```typescript
   export class ContentManager {
     static createContent(
       areaId: string,
       title: string,
       state: AppState,
     ): Content {
       const area = state.areas.find((a) => a.id === areaId);
       if (!area) {
         throw new Error(`Area ${areaId} not found`);
       }
       const id = generateId(); // uuid ou nanoid
       const now = Date.now();
       const content: Content = {
         id,
         areaId,
         title,
         status: 'open',
         body: { shapes: [] },
         properties: [],
         createdAt: now,
         updatedAt: now,
       };
       return content;
     }

     static updateContent(
       contentId: string,
       updates: Partial<Content>,
       state: AppState,
     ): Content {
       const content = this.getContentById(contentId, state);
       if (!content) {
         throw new Error(`Content ${contentId} not found`);
       }
       return {
         ...content,
         ...updates,
         id: content.id, // n√£o permitir mudar ID
         areaId: content.areaId, // n√£o permitir mudar Area
         createdAt: content.createdAt, // n√£o permitir mudar createdAt
         updatedAt: Date.now(),
       };
     }

     // ... outros m√©todos
   }
   ```

2. Use utility functions para IDs:
   ```typescript
   import { nanoid } from 'nanoid';
   export function generateId(): string {
     return nanoid(12);
   }
   ```
   (Instalar: `npm install nanoid`)

3. Testes (`src/managers/ContentManager.test.ts`):
   ```typescript
   describe('ContentManager', () => {
     const state = getDefaultState();
     const area = AreaManager.createArea('Test Area', state);
     state.areas.push(area);

     it('should create content in area', () => {
       const content = ContentManager.createContent('Area ID', 'Test Content', state);
       expect(content.id).toBeDefined();
       expect(content.title).toBe('Test Content');
       expect(content.status).toBe('open');
       expect(content.body.shapes).toEqual([]);
     });

     it('should throw if area does not exist', () => {
       expect(() => {
         ContentManager.createContent('invalid-area', 'Title', state);
       }).toThrow();
     });

     it('should update content title', () => {
       const content = ContentManager.createContent(area.id, 'Original', state);
       const updated = ContentManager.updateContent(content.id, { title: 'Updated' }, state);
       expect(updated.title).toBe('Updated');
       expect(updated.updatedAt).toBeGreaterThan(content.createdAt);
     });

     it('should add shape to content', () => {
       const content = ContentManager.createContent(area.id, 'Test', state);
       const shape: Shape = {
         id: generateId(),
         type: 'rect',
         position: { x: 10, y: 10 },
         dimension: { width: 100, height: 100 },
         style: { fill: '#000' },
         createdAt: Date.now(),
       };
       const updated = ContentManager.addShapeToContent(content.id, shape, state);
       expect(updated.body.shapes).toHaveLength(1);
       expect(updated.body.shapes.id).toBe(shape.id);
     });

     it('should close content', () => {
       const content = ContentManager.createContent(area.id, 'Test', state);
       const closed = ContentManager.closeContent(content.id, state);
       expect(closed.status).toBe('closed');
     });

     it('should validate content', () => {
       const content = { ...ContentManager.createContent(area.id, 'Test', state), title: '' };
       const errors = ContentManager.validateContent(content);
       expect(errors).toContain(expect.stringContaining('title'));
     });
   });
   ```

4. Estrutura de diret√≥rios:
   ```
   src/
   ‚îú‚îÄ‚îÄ managers/
   ‚îÇ   ‚îú‚îÄ‚îÄ ContentManager.ts
   ‚îÇ   ‚îú‚îÄ‚îÄ ContentManager.test.ts
   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
   ‚îú‚îÄ‚îÄ utils/
   ‚îÇ   ‚îî‚îÄ‚îÄ id.ts (generateId function)
   ```

5. Imutabilidade patterns:
   - Usar spread operator (`...`) para copiar objetos
   - Usar `Array.prototype.map()`, `filter()`, `concat()` para arrays (nunca `push`, `splice`)
   - Retornar novo estado, nunca mutar par√¢metros

SA√çDA ESPERADA:
- `src/managers/ContentManager.ts` com todos os 14 m√©todos est√°ticos.
- `src/managers/ContentManager.test.ts` com testes (>85% coverage).
- `src/utils/id.ts` com `generateId()`.
- Todas opera√ß√µes retornam novo objeto (imut√°vel).

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test` passa em ContentManager.test.ts.
- [ ] Todos os m√©todos s√£o est√°ticos (stateless).
- [ ] Sem muta√ß√£o direta (spread/concat).
- [ ] Valida√ß√£o de pr√©-condi√ß√µes (erro se Area n√£o existe, etc.).
- [ ] TypeScript strict, sem `any`.
- [ ] Coverage >85%.

N√ÉO FAZER:
- N√£o modificar estado global (managers s√£o fun√ß√µes puras).
- N√£o fazer chamadas a API (tudo local).
- N√£o criar UI; apenas l√≥gica.
```

***

### ETAPA 2: Implementar AreaManager

**Objetivo:**  
Criar manager que encapsula opera√ß√µes CRUD em √°reas (Area).

**Arquivos principais a tocar:**
- `src/managers/AreaManager.ts`
- `src/managers/AreaManager.test.ts`

**Prompt para IA:**

```text
Voc√™ √© um engenheiro de software s√™nior especializado em domain logic.

TAREFA:
Implementar `AreaManager`: uma classe que centraliza toda a l√≥gica de CRUD de √°reas (Area) na aplica√ß√£o BOUND.

CONTEXTO IMPORTANTE:
- Area √© um agrupamento de Conte√∫dos.
- Nomes de √°reas devem ser √∫nicos dentro da sess√£o.
- Ao deletar Area, todos os Conte√∫dos dela tamb√©m s√£o deletados (cascata).
- AreaManager √© stateless (functional style, retorna novo estado).

FUNCIONALIDADE DESEJADA:

1. **createArea(name: string, state: AppState): Area**
   - Criar nova Area com ID gerado, name, contentIds=[], backgroundColor=undefined.
   - Validar: name n√£o √© vazio, name √© √∫nico em state.areas.
   - Retornar nova Area.

2. **updateArea(areaId: string, updates: Partial<Area>, state: AppState): Area**
   - Atualizar name, backgroundColor, etc.
   - Validar: areaId existe, novo name √© √∫nico (se mudando nome).
   - Retornar Area atualizado.

3. **deleteArea(areaId: string, state: AppState): { success: boolean; reason?: string }**
   - Deletar Area.
   - Side effect: remover todos os Conte√∫dos dessa area (cascata).
   - Retornar { success: true } ou erro.

4. **renameArea(areaId: string, newName: string, state: AppState): Area**
   - Alias para updateArea({ name: newName }).
   - Validar: name √© √∫nico.

5. **addContentToArea(areaId: string, contentId: string, state: AppState): Area**
   - Adicionar contentId a area.contentIds.
   - Validar: Area existe, Content existe, n√£o est√° j√° na area.

6. **removeContentFromArea(areaId: string, contentId: string, state: AppState): Area**
   - Remover contentId de area.contentIds.
   - Validar: Area existe, Content existe.

7. **getAreaById(areaId: string, state: AppState): Area | undefined**
   - Helper.

8. **getAreaByName(name: string, state: AppState): Area | undefined**
   - Helper (procura por name √∫nico).

9. **validateArea(area: Area): string[]**
   - Retornar erros de valida√ß√£o.

INSTRU√á√ïES T√âCNICAS:

1. Similar a ContentManager, usar spread operator para imutabilidade.
2. M√©todo `isAreaNameUnique(name: string, state: AppState, excludeId?: string)` helper.
3. Testes: >85% coverage.

SA√çDA ESPERADA:
- `src/managers/AreaManager.ts` com todos os m√©todos.
- `src/managers/AreaManager.test.ts` com testes >85%.

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test` passa.
- [ ] Nomes √∫nicos validados.
- [ ] Cascata delete: deletar Area ‚Üí deletar Conte√∫dos.
- [ ] Imut√°vel.
- [ ] TypeScript strict.

N√ÉO FAZER:
- N√£o deletar Links manualmente (LinkManager cuida).
- N√£o fazer UI.
```

***

### ETAPA 3: Implementar PropertyManager

**Objetivo:**  
Criar manager que encapsula l√≥gica de propriedades (Property), incluindo valida√ß√£o de tipo.

**Arquivos principais a tocar:**
- `src/managers/PropertyManager.ts`
- `src/managers/PropertyManager.test.ts`

**Prompt para IA:**

```text
Voc√™ √© um engenheiro de software s√™nior.

TAREFA:
Implementar `PropertyManager`: centraliza l√≥gica de opera√ß√µes em Propriedades (Property).

CONTEXTO IMPORTANTE:
- Property tem tipos: 'tag' | 'date' | 'shortText' | 'longText' | 'number' | 'link'.
- Cada tipo tem valida√ß√£o espec√≠fica (ex: date √© timestamp, number √© validado).
- PropertyManager √© stateless.

FUNCIONALIDADE DESEJADA:

1. **createProperty(name: string, type: PropertyType, value: unknown, state: AppState): Property**
   - Criar Property com ID gerado.
   - Validar: name n√£o √© vazio, value √© compat√≠vel com type.
   - Retornar Property.

2. **validatePropertyValue(type: PropertyType, value: unknown): { valid: boolean; error?: string }**
   - Validar se valor √© compat√≠vel com tipo.
   - Exemplos:
     - type='number' ‚Üí value deve ser number
     - type='date' ‚Üí value deve ser number (timestamp) ou Date
     - type='link' ‚Üí value deve ser contentId (string)
     - type='tag' ‚Üí value pode ser string ou array de strings

3. **coercePropertyValue(type: PropertyType, value: unknown): unknown**
   - Converter valor para tipo correto (ex: date string ‚Üí timestamp).
   - Se inv√°lido, retornar undefined.

4. **updateProperty(property: Property, updates: Partial<Property>): Property**
   - Atualizar Property (imut√°vel).
   - Validar novo tipo/valor se mudando.

5. **formatPropertyValue(type: PropertyType, value: unknown): string**
   - Retornar string formatada para exibi√ß√£o.
   - Ex: date ‚Üí "12/02/2026", number ‚Üí "42", etc.

INSTRU√á√ïES T√âCNICAS:

1. Enum/map de validators:
   ```typescript
   const validators: Record<PropertyType, (value: unknown) => boolean> = {
     tag: (v) => typeof v === 'string' || Array.isArray(v),
     date: (v) => typeof v === 'number' && v > 0,
     shortText: (v) => typeof v === 'string' && v.length <= 100,
     longText: (v) => typeof v === 'string',
     number: (v) => typeof v === 'number',
     link: (v) => typeof v === 'string', // contentId
   };
   ```

2. Testes: >85% coverage.

SA√çDA ESPERADA:
- `src/managers/PropertyManager.ts`.
- `src/managers/PropertyManager.test.ts` com testes.

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test` passa.
- [ ] Valida√ß√£o por tipo funciona.
- [ ] Coer√ß√£o correta.
- [ ] Formatting correto.

N√ÉO FAZER:
- N√£o fazer UI.
```

***

### ETAPA 4: Implementar LinkManager

**Objetivo:**  
Criar manager que encapsula l√≥gica de links (Link) entre conte√∫dos, incluindo links manuais e autom√°ticos via propriedade.

**Arquivos principais a tocar:**
- `src/managers/LinkManager.ts`
- `src/managers/LinkManager.test.ts`

**Prompt para IA:**

```text
Voc√™ √© um engenheiro de software s√™nior.

TAREFA:
Implementar `LinkManager`: centraliza l√≥gica de opera√ß√µes em Links (Link) entre Conte√∫dos.

CONTEXTO IMPORTANTE:
- Link conecta dois Conte√∫dos fechados (ou abertos, sem restri√ß√£o por enquanto).
- LinkType = 'manual' (user cria seta) | 'auto' (criado por Property.type='link').
- Links autom√°ticos s√£o bidirecionais (se A ‚Üí B via propriedade, h√° aresta bidirecional).
- Ao deletar Content, deletar todos os Links associados.
- LinkManager √© stateless.

FUNCIONALIDADE DESEJADA:

1. **createLink(fromContentId: string, toContentId: string, type: LinkType, propertyId?: string, state: AppState): Link**
   - Criar Link.
   - Validar: fromContentId e toContentId existem, n√£o s√£o iguais, link n√£o existe j√°.
   - Se type='auto', propertyId deve estar presente.
   - Retornar Link.

2. **deleteLink(linkId: string, state: AppState): { success: boolean; reason?: string }**
   - Deletar Link.
   - Validar: Link existe.

3. **getLinksByContentId(contentId: string, state: AppState): Link[]**
   - Retornar todos Links onde fromContentId ou toContentId = contentId.

4. **getLinksByPropertyId(propertyId: string, state: AppState): Link[]**
   - Retornar todos Links onde propertyId = propertyId (auto links).

5. **createBidirectionalLinks(contentIdA: string, contentIdB: string, propertyId: string, state: AppState): Link[]**
   - Criar dois Links: A‚ÜíB e B‚ÜíA (para propriedades link bidirecionais).
   - Retornar array de 2 Links.

6. **deleteLinksByPropertyId(propertyId: string, state: AppState): number**
   - Deletar todos os Links associados a uma propriedade.
   - Retornar quantidade deletada (usefful ao remover Property).

7. **validateLink(link: Link): string[]**
   - Retornar erros de valida√ß√£o.

INSTRU√á√ïES T√âCNICAS:

1. Detectar ciclos em grafo (se necess√°rio, avisar).
2. Testes: >85% coverage.

SA√çDA ESPERADA:
- `src/managers/LinkManager.ts`.
- `src/managers/LinkManager.test.ts`.

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test` passa.
- [ ] Links criados corretamente.
- [ ] Links bidirecionais funcionam.
- [ ] Ciclos s√£o detectados (warning ou error).

N√ÉO FAZER:
- N√£o fazer UI.
```

***

### ETAPA 5: Implementar Zustand Store & Sync com LocalStorage

**Objetivo:**  
Criar Zustand store global que gerencia AppState, sincroniza com StorageManager da Fase 0, e exp√µe actions para atualizar estado.

**Arquivos principais a tocar:**
- `src/store/appStore.ts`
- `src/store/index.ts` (export)
- `src/store/appStore.test.ts`

**Prompt para IA:**

```text
Voc√™ √© um especialista em state management com React/Zustand.

TAREFA:
Implementar Zustand store global que gerencia AppState, sincroniza com LocalStorage (via StorageManager), e exp√µe actions para ui consumir.

CONTEXTO IMPORTANTE:
- Store √© criado uma vez na app (singleton).
- Actions delegam opera√ß√µes aos Managers (ContentManager, etc.).
- Ap√≥s cada a√ß√£o, estado √© persistido automaticamente em LocalStorage (debounced para performance).
- Store deve ser test√°vel (sem depend√™ncia de browser APIs).
- Store carrega estado inicial de LocalStorage ao inicializar.

FUNCIONALIDADE DESEJADA:

1. **AppStore State:**
   ```typescript
   interface AppStoreState {
     state: AppState; // estado completo
     isLoading: boolean;
     error: string | null;
     lastSyncTime: number | null;
   }
   ```

2. **AppStore Actions (m√©todos que modificam state):**
   - `setState(newState: AppState): void` - atualizar state completamente
   - `createArea(name: string): void` - criar area (delega a AreaManager)
   - `updateArea(areaId: string, updates: Partial<Area>): void`
   - `deleteArea(areaId: string): void`
   - `createContent(areaId: string, title: string): string` (retorna contentId)
   - `updateContent(contentId: string, updates: Partial<Content>): void`
   - `deleteContent(contentId: string): void`
   - `openContent(contentId: string): void`
   - `closeContent(contentId: string): void`
   - `addShapeToContent(contentId: string, shape: Shape): void`
   - `removeShapeFromContent(contentId: string, shapeId: string): void`
   - `addPropertyToContent(contentId: string, property: Property): void`
   - `removePropertyFromContent(contentId: string, propertyId: string): void`
   - `createLink(fromContentId: string, toContentId: string, type: LinkType, propertyId?: string): string` (retorna linkId)
   - `deleteLink(linkId: string): void`
   - `setCurrentAreaId(areaId: string | undefined): void`
   - `setCurrentContentId(contentId: string | undefined): void`
   - `loadFromStorage(): Promise<void>` - carregar estado de LocalStorage
   - `saveToStorage(): Promise<void>` - salvar estado em LocalStorage
   - `clearAll(): Promise<void>` - limpar tudo

3. **Store implementation com Zustand:**
   ```typescript
   import { create } from 'zustand';
   import { subscribeWithSelector } from 'zustand/middleware';

   export const useAppStore = create<AppStoreState & AppStoreActions>(
     subscribeWithSelector((set, get) => ({
       state: getDefaultState(),
       isLoading: false,
       error: null,
       lastSyncTime: null,

       setState: (newState: AppState) => {
         set({ state: newState });
         get().saveToStorage(); // debounce?
       },

       createArea: (name: string) => {
         const { state } = get();
         try {
           const area = AreaManager.createArea(name, state);
           const newState = {
             ...state,
             areas: [...state.areas, area],
           };
           get().setState(newState);
         } catch (err) {
           set({ error: String(err) });
         }
       },

       // ... outras actions

       loadFromStorage: async () => {
         set({ isLoading: true });
         try {
           const manager = new StorageManager(new LocalStorageAdapter());
           const state = await manager.load();
           set({ state, isLoading: false });
         } catch (err) {
           set({ error: String(err), isLoading: false });
         }
       },

       saveToStorage: async () => {
         try {
           const { state } = get();
           const manager = new StorageManager(new LocalStorageAdapter());
           await manager.save(state);
           set({ lastSyncTime: Date.now() });
         } catch (err) {
           set({ error: String(err) });
         }
       },
     })),
   );
   ```

4. **Debounce de save:**
   - Usar `useShallow` selector ou manual debounce para evitar salvar a cada keystroke.
   - Exemplo: save a cada 2s de inatividade.

5. **Testes:**
   ```typescript
   describe('AppStore', () => {
     it('should initialize with default state', () => {
       const { state } = useAppStore.getState();
       expect(state.areas).toEqual([]);
       expect(state.contents).toEqual([]);
     });

     it('should create area', () => {
       useAppStore.getState().createArea('Test Area');
       const { state } = useAppStore.getState();
       expect(state.areas).toHaveLength(1);
       expect(state.areas.name).toBe('Test Area');
     });

     it('should create content', () => {
       const { state } = useAppStore.getState();
       const areaId = state.areas?.id;
       if (areaId) {
         useAppStore.getState().createContent(areaId, 'Test Content');
         const { state: newState } = useAppStore.getState();
         expect(newState.contents).toHaveLength(1);
       }
     });
   });
   ```

INSTRU√á√ïES T√âCNICAS:

1. Instalar Zustand:
   ```bash
   npm install zustand
   ```

2. Use middleware `subscribeWithSelector` para selectors avan√ßados.

3. Debounce com `setTimeout`:
   ```typescript
   let saveTimer: NodeJS.Timeout | null = null;
   const debouncedSave = () => {
     if (saveTimer) clearTimeout(saveTimer);
     saveTimer = setTimeout(() => {
       get().saveToStorage();
     }, 2000); // 2s inatividade
   };
   ```

4. Store deve ser criado uma √∫nica vez (m√≥dulo singleton).

5. Testes: >85% coverage.

SA√çDA ESPERADA:
- `src/store/appStore.ts` com Zustand store.
- `src/store/appStore.test.ts` com testes.
- Store inicializa de LocalStorage.
- Actions delegam aos Managers.
- Auto-save com debounce.

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test` passa appStore.test.ts.
- [ ] Store sincroniza com LocalStorage.
- [ ] Actions modificam estado corretamente.
- [ ] Debounce funciona (2s inatividade).
- [ ] TypeScript strict.
- [ ] Coverage >85%.

N√ÉO FAZER:
- N√£o fazer UI; apenas store.
- N√£o salvar a cada keystroke (debounce).
```

***

### ETAPA 6: Implementar Hooks Customizados

**Objetivo:**  
Criar hooks React que exp√µem funcionalidades do store, facilitando consumo em componentes.

**Arquivos principais a tocar:**
- `src/hooks/useContent.ts`
- `src/hooks/useArea.ts`
- `src/hooks/useGraph.ts`
- `src/hooks/useNavigation.ts`
- `src/hooks/index.ts` (export)

**Prompt para IA:**

```text
Voc√™ √© um expert em React Hooks e state management.

TAREFA:
Implementar hooks customizados que encapsulam a l√≥gica de acesso ao Zustand store, facilitando componentes React consumir dados/a√ß√µes de forma simples.

CONTEXTO IMPORTANTE:
- Hooks s√£o wrappers que retornam dados e fun√ß√µes prontas para UI usar.
- Hooks usam seletores (Zustand `useShallow`) para evitar re-renders desnecess√°rios.
- Cada hook foca em um dom√≠nio: Content, Area, Graph, Navigation.

FUNCIONALIDADE DESEJADA:

1. **useContent(contentId?: string)**
   ```typescript
   const {
     content, // Content atual (ou undefined se contentId inv√°lido)
     isOpen, // boolean
     isClosed, // boolean
     updateTitle, // (newTitle: string) => void
     addShape, // (shape: Shape) => void
     removeShape, // (shapeId: string) => void
     addProperty, // (property: Property) => void
     removeProperty, // (propertyId: string) => void
     open, // () => void
     close, // () => void
   } = useContent(contentId);
   ```

2. **useArea(areaId?: string)**
   ```typescript
   const {
     area, // Area atual
     contents, // Content[] dessa area
     update, // (updates: Partial<Area>) => void
     delete: deleteArea, // () => void
     rename, // (newName: string) => void
     createContent, // (title: string) => string (retorna contentId)
   } = useArea(areaId);
   ```

3. **useAreas()**
   ```typescript
   const {
     areas, // Area[]
     create, // (name: string) => void
   } = useAreas();
   ```

4. **useGraph(areaId?: string)**
   ```typescript
   const {
     nodes, // GraphNode[]
     edges, // GraphEdge[]
     refresh, // () => void (recalcular grafo)
     recomputePositions, // (layout: 'force' | 'circular') => void (Fase 3)
   } = useGraph(areaId);
   ```

5. **useNavigation()**
   ```typescript
   const {
     currentAreaId, // string | undefined
     currentContentId, // string | undefined
     goToArea, // (areaId: string) => void
     goToContent, // (contentId: string) => void
     goHome, // () => void
   } = useNavigation();
   ```

6. **useStorage()**
   ```typescript
   const {
     isLoading, // boolean
     error, // string | null
     loadFromStorage, // () => Promise<void>
     saveToStorage, // () => Promise<void>
     clearAll, // () => Promise<void>
   } = useStorage();
   ```

INSTRU√á√ïES T√âCNICAS:

1. Usar `useShallow` (Zustand) para seletores de objetos:
   ```typescript
   export function useArea(areaId?: string) {
     const areas = useAppStore((state) => state.state.areas);
     const area = areas.find((a) => a.id === areaId);
     const { state } = useAppStore(
       useShallow((s) => ({ state: s.state })),
     );
     // ... computar contents, etc.
     return { area, contents, update, ... };
   }
   ```

2. Memoizar valores derivados (useMemo) se computa√ß√£o √© cara.

3. Testes: >80% coverage com hooks rendering.

SA√çDA ESPERADA:
- `src/hooks/useContent.ts`
- `src/hooks/useArea.ts`
- `src/hooks/useAreas.ts`
- `src/hooks/useGraph.ts`
- `src/hooks/useNavigation.ts`
- `src/hooks/useStorage.ts`
- `src/hooks/index.ts` (export all)

CRIT√âRIOS DE ACEITE:
- [ ] Todos os hooks funcionam.
- [ ] Testes passam >80% coverage.
- [ ] Sem re-renders desnecess√°rios (seletores otimizados).
- [ ] TypeScript strict.

N√ÉO FAZER:
- N√£o fazer UI; apenas hooks.
```

***

### ETAPA 7: Testes Integrados & Valida√ß√£o Final

**Objetivo:**  
Realizar testes integrados (managers + store + hooks), garantir cobertura >85%, e validar que tudo funciona junto.

**Arquivos principais a tocar:**
- `src/tests/integration/workflow.test.ts`
- `src/tests/README.md` (documenta√ß√£o de testes)

**Prompt para IA:**

```text
Voc√™ √© um expert em testes de software (unit + integration).

TAREFA:
Implementar testes integrados que validam fluxos completos da aplica√ß√£o BOUND (Fase 1), garantindo que Managers + Store + Hooks trabalham juntos corretamente.

CONTEXTO IMPORTANTE:
- Testes integrados simulam cen√°rios reais de uso (ex: criar area ‚Üí criar conte√∫do ‚Üí editar ‚Üí fechar ‚Üí aparecer no grafo).
- Cobertura deve ser >85% (lines, statements, branches).
- N√£o h√° UI; apenas l√≥gica.

FUNCIONALIDADE DESEJADA:

1. **Workflow completo (create area ‚Üí create content ‚Üí add shapes ‚Üí add property ‚Üí close ‚Üí link)**
   ```typescript
   describe('Full Workflow', () => {
     it('should create area, content, shapes, properties, and link', async () => {
       const store = useAppStore.getState();
       
       // 1. Create area
       store.createArea('Workspace');
       const { state } = store;
       const areaId = state.areas!.id;
       
       // 2. Create content
       const contentId1 = store.createContent(areaId, 'Note 1');
       const contentId2 = store.createContent(areaId, 'Note 2');
       
       // 3. Add shapes to content 1
       const shape1: Shape = { /* ... */ };
       store.addShapeToContent(contentId1, shape1);
       
       // 4. Add property (link type)
       const prop: Property = {
         id: generateId(),
         name: 'Relates to',
         type: 'link',
         value: contentId2,
         createdAt: Date.now(),
       };
       store.addPropertyToContent(contentId1, prop);
       
       // 5. Close content 1 (vira n√≥)
       store.closeContent(contentId1);
       
       // 6. Check grafo
       const { nodes, edges } = useGraph(areaId).getState();
       expect(nodes).toHaveLength(1); // content1 closed = 1 node
       expect(edges).toHaveLength(1); // link autom√°tico
       
       // 7. Link manual content1 ‚Üí content2
       store.createLink(contentId1, contentId2, 'manual');
       const { edges: edges2 } = useGraph(areaId).getState();
       expect(edges2).toHaveLength(2); // 1 auto + 1 manual
     });
   });
   ```

2. **Property type validation**
   ```typescript
   describe('Property Type Validation', () => {
     it('should validate number property', () => {
       const { valid, error } = PropertyManager.validatePropertyValue('number', 42);
       expect(valid).toBe(true);
       
       const { valid: v2, error: e2 } = PropertyManager.validatePropertyValue('number', 'not a number');
       expect(v2).toBe(false);
     });
   });
   ```

3. **Storage roundtrip**
   ```typescript
   describe('Storage Roundtrip', () => {
     it('should save and load state without loss', async () => {
       // Build complex state
       // Save
       // Load
       // Verify identical
     });
   });
   ```

INSTRU√á√ïES T√âCNICAS:

1. Use `npm run test -- --coverage` para gerar relat√≥rio.
2. Configure Vitest para coverage reports.
3. Arquivo README.md em `src/tests/` explicando estrat√©gia de testes.

SA√çDA ESPERADA:
- `src/tests/integration/workflow.test.ts` com testes de fluxo completo.
- Coverage report >85%.
- `src/tests/README.md` documenta√ß√£o.

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test` passa todas as suites.
- [ ] Coverage >85% (lines, statements, branches).
- [ ] Fluxos realistas testados.
- [ ] Sem memory leaks (cleanup em tests).

N√ÉO FAZER:
- N√£o fazer UI.
```

***

## Como Validar Localmente

Ap√≥s completar ETAPA 1-7, execute:

```bash
# 1. Type Check
npm run type-check
npm run lint

# 2. Testes Unit√°rios
npm run test                    # Rodar todos os testes
npm run test -- --coverage      # Com coverage report
npm run test:ui                 # UI visual do Vitest

# 3. Build
npm run build

# 4. Verifique Coverage
# Deve ser >85% em lines, statements, branches
```

***

## O que Deve Estar Acess√≠vel na UI ao Final

**Nenhuma UI visual ainda.** Mas:

- ‚úÖ **APIs funcionais:**
  - `useAppStore` (store global)
  - `useContent(contentId)` (hook)
  - `useArea(areaId)` (hook)
  - `useAreas()` (hook)
  - `useGraph(areaId)` (hook)
  - `useNavigation()` (hook)
  - `useStorage()` (hook)

- ‚úÖ **Managers funcionais (sem UI, apenas APIs):**
  - `ContentManager.createContent(areaId, title, state)`
  - `AreaManager.createArea(name, state)`
  - `PropertyManager.validatePropertyValue(type, value)`
  - `LinkManager.createLink(fromId, toId, type, state)`

- ‚úÖ **Testes:** >85% coverage

***

## Pr√≥xima Fase (Teaser)

**Fase 2: Canvas Editor (Quadro Negro)**  
Implementaremos o editor de conte√∫do tipo "quadro negro" usando **Konva.js**, onde o user desenha shapes (ret√¢ngulo, c√≠rculo, seta, texto), escolhe cores e fontes. Integraremos com `useContent()` para persistir shapes. Undo/Redo ser√° implementado com stack. Ao final: editor funcional integrando canvas + l√≥gica da Fase 1.

***
