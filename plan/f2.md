# üìÑ FASE 2: Canvas Editor (Quadro Negro)

## ESTRUTURA GERAL

A **Fase 2** implementa o editor visual tipo "quadro negro" (inspirado em Excalidraw) onde o usu√°rio desenha shapes (ret√¢ngulos, c√≠rculos, linhas, setas, texto), personaliza cores e fontes, e persiste tudo em `Content.body.shapes`. Seu objetivo √© criar:

1. **Canvas Component** usando Konva.js que renderiza shapes e permite intera√ß√£o (drag, resize, delete)
2. **Toolbar** com ferramentas de desenho, color picker, font selector
3. **Undo/Redo Manager** que mant√©m stack de estados canvas
4. **Shape Factory** e Serializer para converter shapes ‚Üî JSON
5. **Integra√ß√£o com Hooks** (`useContent`) para persistir altera√ß√µes

Ao final da Fase 2, voc√™ ter√° um **editor funcional e completo** onde conte√∫dos abertos podem ter seus corpos editados visualmente, sem UI de navega√ß√£o (roteamento ser√° Fase 4).

***

## FASE 2: Canvas Editor (Quadro Negro)

### ETAPA 1: Instala√ß√£o & Configura√ß√£o de Konva.js

**Objetivo:**  
Instalar Konva.js e configurar types, assets, e estrutura para o editor canvas.

**Arquivos principais a tocar:**
- `package.json`
- `vite.config.ts` (se necess√°rio ajustar)
- `src/types/canvas.ts` (tipos espec√≠ficos de canvas)
- `src/constants/canvas.ts` (defaults, cores, fonts)

**Prompt para IA:**

```text
Voc√™ √© um engenheiro frontend especializado em bibliotecas de canvas e visualization.

TAREFA:
Instalar e configurar Konva.js para a aplica√ß√£o BOUND, preparando estrutura base para o editor de shapes.

CONTEXTO IMPORTANTE:
- Konva.js √© uma biblioteca 2D canvas que facilita manipula√ß√£o de shapes, layers, e eventos.
- Performance √© cr√≠tica: queremos renderizar centenas de shapes sem lag.
- Modo escuro obrigat√≥rio: backgrounds escuros, shapes com cores customiz√°veis.
- Sem depend√™ncias extras desnecess√°rias (manter bundle leve).

FUNCIONALIDADE DESEJADA:

1. **Instala√ß√£o de Konva.js:**
   - `npm install konva react-konva`
   - `npm install --save-dev @types/konva`

2. **Tipos TypeScript para Canvas:**
   ```typescript
   // src/types/canvas.ts
   export enum ToolType {
     SELECT = 'select',
     RECT = 'rect',
     CIRCLE = 'circle',
     LINE = 'line',
     ARROW = 'arrow',
     TEXT = 'text',
     ERASER = 'eraser',
   }

   export interface CanvasState {
     tool: ToolType; // ferramenta ativa
     selectedShapeId?: string;
     fillColor: string; // hex
     strokeColor: string;
     strokeWidth: number;
     fontFamily: string;
     fontSize: number;
     fontColor: string;
     opacity: number;
   }

   export interface CanvasHistory {
     past: Shape[][];  // stack de hist√≥ricos
     present: Shape[]; // estado atual
     future: Shape[][]; // para redo
   }
   ```

3. **Constantes (cores, fonts, defaults):**
   ```typescript
   // src/constants/canvas.ts
   export const DEFAULT_CANVAS_STATE: CanvasState = {
     tool: ToolType.SELECT,
     fillColor: '#1a1a2e', // escuro
     strokeColor: '#00d4ff', // ciano (bom contraste)
     strokeWidth: 2,
     fontFamily: 'Arial',
     fontSize: 16,
     fontColor: '#f1f1f1',
     opacity: 1,
   };

   export const WEB_SAFE_FONTS = [
     'Arial',
     'Helvetica',
     'Times New Roman',
     'Courier New',
     'Georgia',
     'Verdana',
   ];

   export const PREDEFINED_COLORS = [
     '#00d4ff', // ciano
     '#ff006e', // pink
     '#ffbe0b', // amarelo
     '#8338ec', // roxo
     '#3a86ff', // azul
     '#06ffa5', // verde
     '#ffffff', // branco
     '#1a1a2e', // escuro (bg)
   ];
   ```

4. **Vite Config (tree-shaking de Konva):**
   - Konva.js j√° √© bem otimizado; verificar que tree-shaking est√° habilitado em `vite.config.ts`.

INSTRU√á√ïES T√âCNICAS:

1. Execute:
   ```bash
   npm install konva react-konva @types/konva
   ```

2. Crie `src/types/canvas.ts`:
   - Enum ToolType
   - Interface CanvasState
   - Interface CanvasHistory

3. Crie `src/constants/canvas.ts`:
   - DEFAULT_CANVAS_STATE
   - WEB_SAFE_FONTS
   - PREDEFINED_COLORS
   - DEFAULT_SHAPE_STYLES

4. Validar que Konva n√£o aumenta bundle muito (deve ser <50KB min gzipped).

5. Sem testes complexos; apenas type check.

SA√çDA ESPERADA:
- Konva.js instalado e dispon√≠vel.
- Types definidos em `src/types/canvas.ts`.
- Constantes em `src/constants/canvas.ts`.
- TypeScript sem erros.

CRIT√âRIOS DE ACEITE:
- [ ] `npm install` funciona.
- [ ] `npm run type-check` passa.
- [ ] Konva pode ser importado: `import Konva from 'konva'`.
- [ ] `import { Stage, Layer, Rect } from 'react-konva'` funciona.
- [ ] Bundle check: Konva <50KB gzipped.

N√ÉO FAZER:
- N√£o usar Fabric.js (j√° escolhemos Konva).
- N√£o instalar plugins desnecess√°rios de Konva.
- N√£o fazer UI ainda.
```

***

### ETAPA 2: Implementar Shape Factory & Serializer

**Objetivo:**  
Criar utilit√°rios para criar, serializar e desserializar shapes (Konva objects ‚Üî JSON).

**Arquivos principais a tocar:**
- `src/utils/canvas/shapeFactory.ts`
- `src/utils/canvas/shapeSerializer.ts`
- `src/utils/canvas/index.ts` (export)

**Prompt para IA:**

```text
Voc√™ √© um engenheiro de software especializado em data transformation e design patterns.

TAREFA:
Implementar Shape Factory e Serializer: utilit√°rios que criam, convertem e persistem shapes entre Konva.js objects e estrutura JSON (Shape type).

CONTEXTO IMPORTANTE:
- Shape (tipo do dom√≠nio) deve ser 100% agn√≥stico de Konva.
- Factory cria Konva.Shapes a partir de Shape (dom√≠nio) + CanvasState (cores, fonts, etc.).
- Serializer converte Konva objects de volta para Shape (dom√≠nio).
- Imutabilidade: factory retorna novo objeto, n√£o muta.

FUNCIONALIDADE DESEJADA:

1. **ShapeFactory (static methods):**
   ```typescript
   export class ShapeFactory {
     static createRect(
       position: Position,
       dimension: Dimension,
       state: CanvasState,
     ): Shape {
       // Retornar Shape tipo 'rect'
       const shape: Shape = {
         id: generateId(),
         type: 'rect',
         position,
         dimension,
         style: {
           fill: state.fillColor,
           stroke: state.strokeColor,
           strokeWidth: state.strokeWidth,
           opacity: state.opacity,
         },
         createdAt: Date.now(),
       };
       return shape;
     }

     static createCircle(...): Shape { /* similar */ }
     static createLine(...): Shape { /* similar */ }
     static createArrow(...): Shape { /* similar */ }
     static createText(content: string, ...): Shape { /* com fontStyle */ }

     // Converter Shape para Konva Group
     static toKonvaShape(shape: Shape): Konva.Group {
       // Retornar Konva.Group com Rect/Circle/Text/Line dentro
       // incluir event handlers (dragstart, dragmove, etc.)
     }

     // Converter Konva Group de volta para Shape
     static fromKonvaShape(konvaGroup: Konva.Group): Shape {
       // Extrair posi√ß√£o, dimens√£o, estilo, id
       // Retornar Shape
     }
   }
   ```

2. **ShapeSerializer:**
   ```typescript
   export class ShapeSerializer {
     // Serializar array de Shapes para JSON
     static encode(shapes: Shape[]): string {
       return JSON.stringify(shapes);
     }

     // Desserializar JSON para array de Shapes
     static decode(json: string): Shape[] {
       const parsed = JSON.parse(json);
       // Validar cada shape com isShape()
       return parsed.filter(isShape);
     }

     // Validar shape (type guard)
     static validate(obj: unknown): obj is Shape {
       return isShape(obj);
     }
   }
   ```

3. **Position & Dimension Helpers:**
   ```typescript
   export function addPositions(a: Position, b: Position): Position {
     return { x: a.x + b.x, y: a.y + b.y };
   }

   export function subtractPositions(a: Position, b: Position): Position {
     return { x: a.x - b.x, y: a.y - b.y };
   }

   export function clampDimension(dim: Dimension): Dimension {
     return {
       width: Math.max(dim.width, 1), // m√≠nimo 1px
       height: Math.max(dim.height, 1),
     };
   }
   ```

INSTRU√á√ïES T√âCNICAS:

1. Crie `src/utils/canvas/shapeFactory.ts`:
   - ShapeFactory class com m√©todos static
   - Cada m√©todo createX cria Shape (dom√≠nio), n√£o Konva object

2. Crie `src/utils/canvas/shapeSerializer.ts`:
   - ShapeSerializer class
   - encode/decode/validate

3. Crie `src/utils/canvas/index.ts`:
   - Export ShapeFactory, ShapeSerializer

4. Testes (`src/utils/canvas/*.test.ts`):
   ```typescript
   describe('ShapeFactory', () => {
     it('should create rect shape', () => {
       const shape = ShapeFactory.createRect(
         { x: 10, y: 10 },
         { width: 100, height: 100 },
         DEFAULT_CANVAS_STATE,
       );
       expect(shape.type).toBe('rect');
       expect(shape.position).toEqual({ x: 10, y: 10 });
       expect(shape.style.fill).toBe(DEFAULT_CANVAS_STATE.fillColor);
     });

     it('should convert shape to Konva and back', () => {
       const original = ShapeFactory.createRect(...);
       const konva = ShapeFactory.toKonvaShape(original);
       const restored = ShapeFactory.fromKonvaShape(konva);
       expect(restored.type).toBe(original.type);
       expect(restored.position).toEqual(original.position);
     });
   });

   describe('ShapeSerializer', () => {
     it('should encode/decode shapes', () => {
       const shapes = [
         ShapeFactory.createRect(...),
         ShapeFactory.createCircle(...),
       ];
       const encoded = ShapeSerializer.encode(shapes);
       const decoded = ShapeSerializer.decode(encoded);
       expect(decoded).toHaveLength(2);
       expect(decoded.type).toBe('rect');
     });
   });
   ```

5. Coverage >85%.

SA√çDA ESPERADA:
- `src/utils/canvas/shapeFactory.ts`
- `src/utils/canvas/shapeSerializer.ts`
- `src/utils/canvas/*.test.ts` com cobertura >85%

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test` passa canvas tests.
- [ ] Shapes podem ser criados, serializados, desserializados.
- [ ] Roundtrip: Shape ‚Üí JSON ‚Üí Shape sem perda.
- [ ] TypeScript strict.

N√ÉO FAZER:
- N√£o criar Konva objects aqui (apenas Shape dom√≠nio).
- N√£o fazer UI.
```

***

### ETAPA 3: Implementar Canvas Undo/Redo Manager

**Objetivo:**  
Criar manager para hist√≥rico de a√ß√µes (undo/redo), armazenando snapshots de shapes.

**Arquivos principais a tocar:**
- `src/managers/CanvasUndoRedoManager.ts`
- `src/managers/CanvasUndoRedoManager.test.ts`

**Prompt para IA:**

```text
Voc√™ √© um expert em undo/redo systems e state management.

TAREFA:
Implementar `CanvasUndoRedoManager`: gerencia hist√≥rico de estados do canvas (shapes array), permitindo undo (Ctrl+Z) e redo (Ctrl+Shift+Z).

CONTEXTO IMPORTANTE:
- Hist√≥rico usa padr√£o command (salvar snapshots de shapes array).
- Limitado a 50 a√ß√µes (memory constraint).
- Stateless: m√©todo est√°tico recebe CanvasHistory, retorna novo CanvasHistory.

FUNCIONALIDADE DESEJADA:

1. **CanvasUndoRedoManager:**
   ```typescript
   export class CanvasUndoRedoManager {
     static createHistory(): CanvasHistory {
       return { past: [], present: [], future: [] };
     }

     static push(
       shapes: Shape[],
       history: CanvasHistory,
       maxSize: number = 50,
     ): CanvasHistory {
       // Adicionar shapes atual ao past
       // Limpar future (novo branch)
       // Se past > maxSize, remover mais antigo
       return {
         past: [...history.past, history.present].slice(-maxSize),
         present: shapes,
         future: [],
       };
     }

     static undo(history: CanvasHistory): CanvasHistory {
       if (history.past.length === 0) return history;
       const newPast = history.past.slice(0, -1);
       const newPresent = history.past[history.past.length - 1];
       return {
         past: newPast,
         present: newPresent,
         future: [history.present, ...history.future],
       };
     }

     static redo(history: CanvasHistory): CanvasHistory {
       if (history.future.length === 0) return history;
       const newFuture = history.future.slice(1);
       const newPresent = history.future;
       return {
         past: [...history.past, history.present],
         present: newPresent,
         future: newFuture,
       };
     }

     static canUndo(history: CanvasHistory): boolean {
       return history.past.length > 0;
     }

     static canRedo(history: CanvasHistory): boolean {
       return history.future.length > 0;
     }
   }
   ```

2. **Testes:**
   ```typescript
   describe('CanvasUndoRedoManager', () => {
     it('should push shapes to history', () => {
       let history = CanvasUndoRedoManager.createHistory();
       const shapes1 = [ShapeFactory.createRect(...)];
       history = CanvasUndoRedoManager.push(shapes1, history);
       expect(history.present).toEqual(shapes1);

       const shapes2 = [ShapeFactory.createCircle(...)];
       history = CanvasUndoRedoManager.push(shapes2, history);
       expect(history.past).toHaveLength(1);
       expect(history.present).toEqual(shapes2);
     });

     it('should undo', () => {
       let history = CanvasUndoRedoManager.createHistory();
       history = CanvasUndoRedoManager.push([shape1], history);
       history = CanvasUndoRedoManager.push([shape2], history);
       history = CanvasUndoRedoManager.undo(history);
       expect(history.present).toEqual([shape1]);
       expect(history.canUndo(history)).toBe(true);
       expect(history.canRedo(history)).toBe(true);
     });

     it('should limit history size', () => {
       let history = CanvasUndoRedoManager.createHistory();
       for (let i = 0; i < 60; i++) {
         history = CanvasUndoRedoManager.push([{ id: String(i) }], history, 50);
       }
       expect(history.past.length).toBeLessThanOrEqual(50);
     });
   });
   ```

INSTRU√á√ïES T√âCNICAS:

1. Immutable operations (spread, slice).
2. Testes >85% coverage.

SA√çDA ESPERADA:
- `src/managers/CanvasUndoRedoManager.ts`
- `src/managers/CanvasUndoRedoManager.test.ts`

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test` passa.
- [ ] Undo/Redo funcionam bidirecionalmente.
- [ ] Hist√≥ria limitada a 50 items.
- [ ] Coverage >85%.

N√ÉO FAZER:
- N√£o fazer UI.
```

***

### ETAPA 4: Implementar CanvasEditor Component (Konva)

**Objetivo:**  
Criar componente React que renderiza canvas interativo com Konva.js, toolbar de ferramentas, e integra com `useContent`.

**Arquivos principais a tocar:**
- `src/components/CanvasEditor.tsx`
- `src/components/CanvasToolbar.tsx`
- `src/components/ColorPicker.tsx`
- `src/components/FontSelector.tsx`
- `src/hooks/useCanvasEditor.ts` (hook customizado para l√≥gica canvas)

**Prompt para IA:**

```text
Voc√™ √© um expert em React + Konva.js e UI interativa.

TAREFA:
Implementar `CanvasEditor` component: componente React que renderiza canvas interativo usando Konva.js, permite desenhar shapes, personalizar cores/fontes, e integra com `useContent` para persistir.

CONTEXTO IMPORTANTE:
- CanvasEditor renderiza dentro de um Content aberto (ContentPage, Fase 4).
- Modo escuro obrigat√≥rio: background escuro, shapes com cores claras (ciano, rosa, etc.).
- Performance: deve renderizar 100+ shapes suavemente (60 FPS).
- Integra√ß√£o: ao terminar edi√ß√£o (blur, salvar), persist em Content.body.shapes via hook.
- Undo/Redo: Ctrl+Z / Ctrl+Shift+Z.

FUNCIONALIDADE DESEJADA:

1. **CanvasEditor Component:**
   - Renderiza Konva Stage + Layer + shapes
   - Renderiza toolbar com ferramentas
   - Detecta cliques e drags para desenhar/editar shapes
   - Suporta sele√ß√£o, drag, resize, delete
   - Integra√ß√£o com hooks (useContent, custom useCanvasEditor)

2. **Toolbar (abaixo do canvas):**
   - Buttons: Select, Rect, Circle, Line, Arrow, Text, Eraser
   - Color picker (fill + stroke)
   - Font selector
   - Stroke width slider
   - Opacity slider
   - Undo/Redo buttons
   - Clear all button

3. **Features:**
   - Sele√ß√£o de shape: click ‚Üí outline azul, handles de resize
   - Drag: mover shape pelo canvas
   - Resize: handles nas extremidades
   - Delete: press Del ou click em delete button
   - Text shape: double-click para editar texto
   - Keyboard shortcuts: Ctrl+Z, Ctrl+Shift+Z, Del, Escape

4. **useCanvasEditor Hook (internamente):**
   ```typescript
   export function useCanvasEditor(contentId: string) {
     const { content, updateContent, addShapeToContent, removeShapeFromContent } = useContent(contentId);
     
     const [canvasState, setCanvasState] = useState<CanvasState>(DEFAULT_CANVAS_STATE);
     const [history, setHistory] = useState<CanvasHistory>(() =>
       CanvasUndoRedoManager.createHistory()
     );
     const [selectedShapeId, setSelectedShapeId] = useState<string | undefined>();

     const addShape = (shape: Shape) => {
       // Adicionar shape a content + ao history
       addShapeToContent(contentId, shape);
       setHistory(CanvasUndoRedoManager.push(newShapes, history));
     };

     const removeShape = (shapeId: string) => {
       removeShapeFromContent(contentId, shapeId);
       setHistory(CanvasUndoRedoManager.push(newShapes, history));
     };

     const undo = () => {
       const newHistory = CanvasUndoRedoManager.undo(history);
       setHistory(newHistory);
       // Atualizar content com newHistory.present
     };

     const redo = () => {
       // Similar a undo
     };

     return {
       canvasState,
       setCanvasState,
       shapes: content?.body.shapes || [],
       addShape,
       removeShape,
       undo,
       redo,
       canUndo: CanvasUndoRedoManager.canUndo(history),
       canRedo: CanvasUndoRedoManager.canRedo(history),
       selectedShapeId,
       setSelectedShapeId,
     };
   }
   ```

INSTRU√á√ïES T√âCNICAS:

1. Crie `src/hooks/useCanvasEditor.ts`:
   - Hook que encapsula l√≥gica de canvas (state, history, add/remove shapes)
   - Integra com `useContent`

2. Crie `src/components/CanvasEditor.tsx`:
   ```typescript
   export function CanvasEditor({ contentId }: { contentId: string }) {
     const {
       canvasState,
       setCanvasState,
       shapes,
       addShape,
       removeShape,
       undo,
       redo,
       canUndo,
       canRedo,
       selectedShapeId,
       setSelectedShapeId,
     } = useCanvasEditor(contentId);

     const stageRef = useRef<Konva.Stage>(null);
     const [isDrawing, setIsDrawing] = useState(false);
     const [startPos, setStartPos] = useState<Position | null>(null);

     const handleMouseDown = (e: KonvaEventObject<MouseEvent>) => {
       // Se tool=SELECT, checar se clicou em shape existente
       // Se tool=RECT/CIRCLE/etc, iniciar drawmode
       if (canvasState.tool !== 'select') {
         setIsDrawing(true);
         setStartPos({ x: e.evt.offsetX, y: e.evt.offsetY });
       }
     };

     const handleMouseMove = (e: KonvaEventObject<MouseEvent>) => {
       if (!isDrawing || !startPos) return;
       // Desenhar preview do shape sendo criado
     };

     const handleMouseUp = (e: KonvaEventObject<MouseEvent>) => {
       if (!isDrawing || !startPos) return;
       const endPos = { x: e.evt.offsetX, y: e.evt.offsetY };
       
       // Criar shape baseado em tool
       const shape = this.createShapeFromTool(startPos, endPos, canvasState.tool);
       addShape(shape);
       
       setIsDrawing(false);
       setStartPos(null);
     };

     const handleKeyDown = (e: React.KeyboardEvent) => {
       if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
         e.preventDefault();
         undo();
       } else if ((e.ctrlKey || e.metaKey) && (e.key === 'z' && e.shiftKey || e.key === 'y')) {
         e.preventDefault();
         redo();
       } else if (e.key === 'Delete' && selectedShapeId) {
         removeShape(selectedShapeId);
       }
     };

     return (
       <div className="canvas-editor" onKeyDown={handleKeyDown}>
         <Stage
           ref={stageRef}
           width={960}
           height={540}
           onMouseDown={handleMouseDown}
           onMouseMove={handleMouseMove}
           onMouseUp={handleMouseUp}
           style={{ backgroundColor: '#1a1a2e' }}
         >
           <Layer>
             {shapes.map((shape) => (
               <ShapeComponent
                 key={shape.id}
                 shape={shape}
                 isSelected={shape.id === selectedShapeId}
                 onSelect={() => setSelectedShapeId(shape.id)}
                 onUpdate={(updated) => { /* update shape */ }}
                 onDelete={() => removeShape(shape.id)}
               />
             ))}
           </Layer>
         </Stage>

         <CanvasToolbar
           canvasState={canvasState}
           onSetCanvasState={setCanvasState}
           canUndo={canUndo}
           onUndo={undo}
           canRedo={canRedo}
           onRedo={redo}
           onClearAll={() => { /* delete all shapes */ }}
         />
       </div>
     );
   }
   ```

3. Crie `src/components/CanvasToolbar.tsx`:
   - Buttons para ferramentas
   - Color pickers
   - Sliders para stroke width, opacity

4. Crie `src/components/ColorPicker.tsx`:
   - Simples: 8 cores predefinidas (ou hex input)

5. Crie `src/components/FontSelector.tsx`:
   - Dropdown com WEB_SAFE_FONTS
   - Font size slider

6. Performance tips:
   - Use `useCallback` para memoizar event handlers
   - Use `React.memo` para ShapeComponent (n√£o re-render se props iguais)
   - Lazy-load canvas se necess√°rio

SA√çDA ESPERADA:
- `src/components/CanvasEditor.tsx`
- `src/components/CanvasToolbar.tsx`
- `src/components/ColorPicker.tsx`
- `src/components/FontSelector.tsx`
- `src/hooks/useCanvasEditor.ts`

CRIT√âRIOS DE ACEITE:
- [ ] Canvas renderiza 100+ shapes sem lag (60 FPS).
- [ ] Sele√ß√£o, drag, resize funcionam.
- [ ] Undo/Redo funcionam (Ctrl+Z, Ctrl+Shift+Z).
- [ ] Shapes persistem em Content.body via hook.
- [ ] Modo escuro aplicado.
- [ ] Toolbar funciona (todos os tools, cores, fonts).
- [ ] Keyboard shortcuts funcionam (Del, Escape).

N√ÉO FAZER:
- N√£o fazer routing (ser√° Fase 4).
- N√£o fazer UI de √°reas/conte√∫dos (apenas canvas editor).
```

***

### ETAPA 5: Criar Shape Components (Konva Wrappers)

**Objetivo:**  
Criar componentes React que renderizam shapes individuais (rect, circle, text, arrow, etc.) com handlers de sele√ß√£o, drag, resize.

**Arquivos principais a tocar:**
- `src/components/shapes/RectShape.tsx`
- `src/components/shapes/CircleShape.tsx`
- `src/components/shapes/TextShape.tsx`
- `src/components/shapes/LineShape.tsx`
- `src/components/shapes/ArrowShape.tsx`
- `src/components/shapes/ShapeComponent.tsx` (factory/dispatcher)

**Prompt para IA:**

```text
Voc√™ √© um expert em React + Konva.js components.

TAREFA:
Implementar shape components: componentes React que renderizam shapes individuais (rect, circle, text, line, arrow) com interatividade (sele√ß√£o, drag, resize).

CONTEXTO IMPORTANTE:
- Cada shape type (rect, circle, etc.) tem seu pr√≥prio componente.
- Todos os shapes suportam: sele√ß√£o (outline), drag, resize, delete, atualizar estilo.
- Selection visual: outline azul com handles de resize (quadrados nas extremidades).
- Modo escuro: backgrounds escuros, cores de outline claras (ciano).

FUNCIONALIDADE DESEJADA:

1. **RectShape Component:**
   - Renderiza `<Rect>` do Konva
   - Handles de sele√ß√£o: 4 handles nos cantos + 4 nas extremidades
   - Drag: mover ret√¢ngulo
   - Resize: arrastar handles muda dimens√£o
   - Delete: press Del ou bot√£o delete
   - Duplo click: editar texto (se for text shape)

2. **CircleShape, TextShape, LineShape, ArrowShape:** Similar

3. **ShapeComponent Factory:**
   ```typescript
   export function ShapeComponent({
     shape,
     isSelected,
     onSelect,
     onUpdate,
     onDelete,
   }: {
     shape: Shape;
     isSelected: boolean;
     onSelect: () => void;
     onUpdate: (updated: Shape) => void;
     onDelete: () => void;
   }) {
     switch (shape.type) {
       case 'rect':
         return <RectShape shape={shape} isSelected={isSelected} {...handlers} />;
       case 'circle':
         return <CircleShape shape={shape} isSelected={isSelected} {...handlers} />;
       // etc.
     }
   }
   ```

INSTRU√á√ïES T√âCNICAS:

1. Use `useRef` para track state de drag/resize.
2. Use `useState` para handles de resize.
3. Implement resize logic com min-width/height de 10px.
4. Double-click em text: mudar para editable mode (contenteditable div overlay, ou Konva.Text editable).

SA√çDA ESPERADA:
- `src/components/shapes/RectShape.tsx`
- `src/components/shapes/CircleShape.tsx`
- `src/components/shapes/TextShape.tsx`
- `src/components/shapes/LineShape.tsx`
- `src/components/shapes/ArrowShape.tsx`
- `src/components/shapes/ShapeComponent.tsx`

CRIT√âRIOS DE ACEITE:
- [ ] Cada shape type renderiza corretamente.
- [ ] Sele√ß√£o visual (outline) funciona.
- [ ] Drag e resize funcionam suavemente.
- [ ] Delete funciona (Del key ou button).
- [ ] TextShape permite edi√ß√£o via double-click.

N√ÉO FAZER:
- N√£o fazer UI de navega√ß√£o.
```

***

### ETAPA 6: Integra√ß√£o com Hooks & Persist√™ncia

**Objetivo:**  
Garantir que altera√ß√µes no canvas s√£o automaticamente persistidas em `Content.body.shapes` via `useContent` hook, sem perder dados.

**Arquivos principais a tocar:**
- `src/hooks/useCanvasEditor.ts` (refinamento)
- `src/components/CanvasEditor.tsx` (refinamento)
- `tests/integration/canvas.integration.test.ts`

**Prompt para IA:**

```text
Voc√™ √© um expert em integra√ß√£o de componentes e persist√™ncia.

TAREFA:
Implementar integra√ß√£o completa entre Canvas Editor e Content (via hooks), garantindo que shapes s√£o persistidos corretamente em LocalStorage.

CONTEXTO IMPORTANTE:
- Ao adicionar shape no canvas, deve-se chamar `addShapeToContent(contentId, shape)` do hook.
- Ao remover shape, chamar `removeShapeFromContent(contentId, shapeId)`.
- Ao sair do editor, state deve estar sincronizado com Content.body.shapes.
- Sem perda de dados ao refresh (LocalStorage persiste).

FUNCIONALIDADE DESEJADA:

1. **Integration Test:**
   ```typescript
   describe('Canvas Editor Integration', () => {
     it('should persist shapes to content', async () => {
       // Renderizar CanvasEditor com contentId
       // Desenhar 3 shapes (rect, circle, text)
       // Salvar/blur
       // Verificar que Content.body.shapes tem 3 items
       // Refresh
       // Verificar que shapes ainda est√£o l√°
     });

     it('should undo/redo and persist', () => {
       // Desenhar 2 shapes
       // Undo ‚Üí 1 shape
       // Redo ‚Üí 2 shapes
       // Verificar persist√™ncia
     });

     it('should handle delete and persist', () => {
       // Desenhar 2 shapes
       // Deletar 1
       // Verificar que Content tem 1 shape
     });
   });
   ```

2. **useCanvasEditor Hook Refinement:**
   - Auto-save com debounce (a cada 2s inatividade)
   - Sincroniza√ß√£o com `useContent`
   - Error handling (ex: Content n√£o existe)

INSTRU√á√ïES T√âCNICAS:

1. Use `useEffect` em CanvasEditor para sincronizar shapes quando mudam.
2. Debounce de saves (2s).
3. Testes de integra√ß√£o E2E (Playwright, Fase 6).

SA√çDA ESPERADA:
- `src/hooks/useCanvasEditor.ts` (refinado)
- `src/components/CanvasEditor.tsx` (refinado)
- `tests/integration/canvas.integration.test.ts`

CRIT√âRIOS DE ACEITE:
- [ ] Shapes persistem em LocalStorage.
- [ ] Roundtrip: criar shape ‚Üí refresh ‚Üí shape ainda l√°.
- [ ] Undo/Redo persistem.
- [ ] Sem lag na persist√™ncia (debounce funciona).

N√ÉO FAZER:
- N√£o fazer routing.
```

***

### ETAPA 7: Testes & Valida√ß√£o Final

**Objetivo:**  
Testes unit√°rios de shapes, canvas manager, e integra√ß√£o completa. Coverage >85%.

**Arquivos principais a tocar:**
- `src/components/shapes/*.test.tsx`
- `src/hooks/useCanvasEditor.test.ts`
- `tests/integration/canvas.*.test.ts`

**Prompt para IA:**

```text
Voc√™ √© um expert em testes React + Konva.

TAREFA:
Implementar suite de testes abrangentes para Canvas Editor (Fase 2).

CONTEXTO IMPORTANTE:
- Testes unit√°rios de shape components.
- Testes de hooks (useCanvasEditor).
- Testes de integra√ß√£o (canvas + content + store).
- Coverage >85%.

FUNCIONALIDADE DESEJADA:

1. **Component Tests (React Testing Library):**
   - RectShape renders correctly
   - CircleShape renders correctly
   - Selection visual (outline) appears
   - Drag works
   - Resize works
   - Double-click to edit text

2. **Hook Tests:**
   - useCanvasEditor initializes
   - addShape updates content
   - removeShape updates content
   - undo/redo work
   - canUndo/canRedo booleans correct

3. **Integration Tests:**
   - Full workflow: canvas ‚Üí shapes ‚Üí persist ‚Üí refresh ‚Üí shapes still there
   - Undo/redo affects persistence
   - Delete removes from content

INSTRU√á√ïES T√âCNICAS:

1. Use `@testing-library/react` + `@testing-library/user-event`.
2. Mock Konva Stage se necess√°rio (pode ser complexo).
3. Coverage report: `npm run test -- --coverage`.

SA√çDA ESPERADA:
- Tests files across src/
- Coverage >85%
- All tests passing

CRIT√âRIOS DE ACEITE:
- [ ] `npm run test` passa todas as suites.
- [ ] Coverage >85%.
- [ ] Fluxos realistas testados.

N√ÉO FAZER:
- N√£o fazer E2E com Playwright (Fase 6).
```

***

## Como Validar Localmente

Ap√≥s completar ETAPA 1-7, execute:

```bash
# 1. Type Check
npm run type-check
npm run lint

# 2. Testes
npm run test                    # Todos os testes
npm run test -- --coverage      # Com coverage

# 3. Build
npm run build

# 4. Dev Server (teste manual)
npm run dev
# Abrir http://localhost:5173
# Dever√° renderizar app com CanvasEditor component
```

***

## O que Deve Estar Acess√≠vel na UI ao Final

- ‚úÖ **Canvas visual:**
  - Stage Konva com fundo escuro (`#1a1a2e`)
  - Shapes renderizados (rect, circle, text, line, arrow)
  - Sele√ß√£o visual (outline azul ao clicar)

- ‚úÖ **Toolbar:**
  - Buttons de ferramentas (Select, Rect, Circle, Line, Arrow, Text, Eraser)
  - Color pickers (fill + stroke)
  - Font selector
  - Sliders (stroke width, opacity)
  - Undo/Redo buttons
  - Clear all button

- ‚úÖ **Interactions:**
  - Desenhar shapes (click + drag)
  - Mover shapes (sele√ß√£o + drag)
  - Redimensionar (handles nas extremidades)
  - Deletar (Del key ou button)
  - Editar texto (double-click)
  - Undo/Redo (Ctrl+Z, Ctrl+Shift+Z)

- ‚úÖ **Persist√™ncia:**
  - Shapes salvos em Content.body.shapes
  - LocalStorage sincronizado
  - Refresh mant√©m shapes

***

## Pr√≥xima Fase (Teaser)

**Fase 3: Graph Visualization & Rendering**  
Implementaremos o visualizador de grafo usando **Cytoscape.js**, onde conte√∫dos fechados aparecem como n√≥s (c√≠rculos com emoji) e links aparecem como arestas. User pode arrastar n√≥s para reposicionar, clicando em um abre o editor. Layout ser√° force-directed ou circular. Ao final: grafo interativo mostrando todos os v√≠nculos.

